{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, Output, ViewChild, HostListener, NgModule } from '@angular/core';\nimport { interval } from 'rxjs';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * A utility class for working with dates.\n */\nconst _c0 = [\"timeline\"];\nconst _c1 = function (a2, a3) {\n  return {\n    cursor: \"pointer\",\n    border: \"1px solid\",\n    borderColor: a2,\n    \"backgroundColor\": a3\n  };\n};\nclass DateUtil {\n  /**\n   * Formats the given date according to the specified format.\n   * @param date The date to format.\n   * @param format The format string, using the following placeholders:\n   *   - YYYY: four-digit year\n   *   - MM: two-digit month (zero-padded)\n   *   - DD: two-digit day of month (zero-padded)\n   *   - HH: two-digit hour (zero-padded, 24-hour format)\n   *   - mm: two-digit minute (zero-padded)\n   *   - ss: two-digit second (zero-padded)\n   * @returns The formatted date string.\n   */\n  static formatDate(date, format) {\n    // Extract the year, month, day, hours, minutes, and seconds from the date\n    const year = date.getFullYear().toString();\n    const month = (date.getMonth() + 1).toString().padStart(2, '0');\n    const day = date.getDate().toString().padStart(2, '0');\n    const hours = date.getHours().toString().padStart(2, '0');\n    const minutes = date.getMinutes().toString().padStart(2, '0');\n    const seconds = date.getSeconds().toString().padStart(2, '0');\n    // Replace the placeholders in the format string with the corresponding date parts\n    return format.replace('YYYY', year).replace('MM', month).replace('DD', day).replace('HH', hours).replace('mm', minutes).replace('ss', seconds);\n  }\n}\nclass NgxVideoTimelineComponent {\n  constructor() {\n    // The height of the outer canvas\n    this.canvasHeight = 50;\n    // Canvas scale is adjusted according to outer height\n    this.scale = this.canvasHeight / 4.55;\n    // The position of the X-axis when the mouse is pressed\n    this.gMousedownCursor = undefined;\n    // The position of the y-axis when the mouse is pressed\n    this.gMousedownCursorY = undefined;\n    // this.startTimeThreshold = new Date().getTime() - 1 * 0.5 * 3600 * 1000;\n    // this.endTimeThreshold = new Date().getTime() + 1 * 1 * 3600 * 1000;\n    this.forWardValue = 5000;\n    this.speed = 1000;\n    this.playTime = new Date().getTime();\n    this.startTimeThreshold = new Date().getTime() - 1 * 12 * 3600 * 1000;\n    this.endTimeThreshold = new Date().getTime() + 1 * 12 * 3600 * 1000;\n    this.playClick = new EventEmitter();\n    this.mouseUp = new EventEmitter();\n    this.mouseDown = new EventEmitter();\n    this.keyUp = new EventEmitter();\n    this.keyDown = new EventEmitter();\n    this.isPlayClick = false;\n    this.videoCells = [{\n      beginTime: new Date().getTime() - 3 * 3600 * 1000,\n      endTime: new Date().getTime() - 1 * 3600 * 1000,\n      style: {\n        background: 'rgba(132, 244, 180, 0.498039)'\n      }\n    }, {\n      beginTime: new Date().getTime() - 6 * 3600 * 1000,\n      endTime: new Date().getTime() - 4 * 3600 * 1000,\n      style: {\n        background: 'rgba(132, 244, 180, 0.498039)'\n      }\n    }];\n    this.verticalBarColor = 'rgba(0,0,0,1)';\n    this.bottomLineColor = 'rgba(0,0,0,1)';\n    this.borderColor = '#fff';\n    this.bgColor = '#fff';\n    this.playBarColor = '#448aff';\n  }\n  /**\n   * Browser change event\n   */\n  onResize() {\n    this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n    this.canvasW = this.canvas.parentNode.offsetWidth;\n    this.init(this.startTimestamp, this.timecell, false);\n  }\n  /**\n   * Keyboard press event\n   */\n  onKeyDown(event) {\n    if (Number(event.keyCode) === 37) {\n      this.playTime = Number(this.playTime) - this.forWardValue;\n      this.currentTimestamp = Number(this.currentTimestamp) - this.forWardValue;\n      this.set_time_to_middle(this.playTime);\n    } else if (Number(event.keyCode === 39)) {\n      this.playTime = Number(this.playTime) + this.forWardValue;\n      this.currentTimestamp = Number(this.currentTimestamp) + this.forWardValue;\n      this.set_time_to_middle(this.playTime);\n    }\n    this.keyDown.emit(this.playTime);\n  }\n  /**\n   * Keyboard release event\n   */\n  onKeyUp(event) {\n    if (Number(event.keyCode) === 13 || Number(event.keyCode === 32)) {\n      this.isPlayClick ? this.onPauseClick() : this.onPlayClick();\n    }\n    this.keyUp.emit(this.playTime);\n  }\n  ngOnInit() {\n    // Initialize data video group event stamp to show new Date().getTime()- number of hours\n    // Assign the Canvas DOM to the variable Canvas\n    this.canvas = this.canvasExp.nativeElement;\n    // Define the area of the canvas\n    this.ctx = this.canvas.getContext('2d');\n    // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n    this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n    // Store the width and height of the canvas\n    this.canvasW = this.canvas.width;\n    this.canvas.height = this.canvasHeight;\n    this.canvasH = this.canvas.height;\n    // Assign the video array to Timecell\n    this.timecell = this.videoCells;\n    // Initialize the number of steps per minute\n    this.minutesPerStep = [1, 2, 5, 10, 15, 20, 30, 60, 120, 180, 240, 360, 720, 1440];\n    // Initialization style\n    // Minimum width between scales, in units of px 20px\n    this.graduationStep = 20;\n    // The timeline shows the time rounded up according to the time threshold\n    this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) : 24;\n    // The leftmost timestamp defaults to 12 hours before the current time\n    this.startTimestamp = Number(this.startTimeThreshold);\n    // Default distance 80\n    this.distanceBetweenGtitle = 80;\n    // Default zoom 24\n    this.zoom = 24;\n    // Default false\n    this.gIsMousedown = false;\n    this.gIsMousemove = false;\n    this.gMousedownCursor = undefined;\n    // px/ms\n    this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n    // The initial X position of the playback icon is in the middle of the scale\n    this.playBarOffsetX = this.canvasW / 2;\n    this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n    this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n    this.playBarOffsetX1 = this.playBarOffsetX - this.scale * 0.6;\n    this.playBarOffsetX2 = this.playBarOffsetX + this.scale * 0.6;\n    this.playBarOffsetY1 = this.scale * 2.5;\n    this.playBarOffsetY2 = this.scale * 3.5;\n    // Initialize the timeline\n    this.init(this.startTimestamp, this.timecell, false);\n    // Draw the play button\n    this.drawPalyBar();\n  }\n  ngOnChanges(changes) {\n    // Refactor the playback component when the width and height change\n    if (changes.canvasHeight) {\n      this.canvasHeight = changes.canvasHeight.currentValue;\n      // Assign the Canvas DOM to the variable Canvas\n      this.canvas = this.canvasExp.nativeElement;\n      // Define the area of the canvas\n      this.ctx = this.canvas.getContext('2d');\n      // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n      this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n      // Store the width and height of the canvas\n      this.canvasW = this.canvas.width;\n      this.canvas.height = this.canvasHeight;\n      this.canvasH = this.canvas.height;\n      // Assign the video array to Timecell\n      this.timecell = this.videoCells;\n      this.minutesPerStep = [1, 2, 5, 10, 15, 20, 30, 60, 120, 180, 240, 360, 720, 1440];\n      // The timeline shows the time rounded up according to the time threshold\n      this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) : 24;\n      // The leftmost timestamp defaults to 12 hours before the current time\n      this.startTimestamp = Number(this.startTimeThreshold);\n      this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n      // The initial X position of the playback icon is in the middle of the scale\n      this.playBarOffsetX = this.canvasW / 2;\n      this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n      // Current timestamp\n      this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n      this.playBarOffsetX1 = this.playBarOffsetX - this.scale * 0.6;\n      this.playBarOffsetX2 = this.playBarOffsetX + this.scale * 0.6;\n      this.playBarOffsetY1 = this.scale * 2.5;\n      this.playBarOffsetY2 = this.scale * 3.5;\n      this.init(this.startTimestamp, this.timecell, false);\n      this.drawPalyBar();\n    }\n    if (changes.videoCells) {\n      this.videoCells = changes.videoCells.currentValue;\n      this.timecell = this.videoCells;\n      this.add_cells(this.timecell);\n      // this.init(this.startTimestamp, this.timecell, true);\n      // this.drawPalyBar();\n    }\n\n    if (changes.startTimeThreshold) {\n      const value = changes.startTimeThreshold.currentValue;\n      if (changes.startTimeThreshold.currentValue instanceof String) {\n        this.startTimeThreshold = new Date(value).getTime();\n      } else if (value instanceof Date) {\n        this.startTimeThreshold = value.getTime();\n      } else if (typeof value === 'number') {\n        this.startTimeThreshold = Number(value);\n      }\n      this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) : 24;\n      this.startTimestamp = Number(this.startTimeThreshold);\n      // this.init(this.startTimestamp, this.timecell, false);\n    }\n\n    if (changes.endTimeThreshold) {\n      const value = changes.endTimeThreshold.currentValue;\n      if (changes.endTimeThreshold.currentValue instanceof String) {\n        this.endTimeThreshold = new Date(value).getTime();\n      } else if (value instanceof Date) {\n        this.endTimeThreshold = value.getTime();\n      } else if (typeof value === 'number') {\n        this.endTimeThreshold = Number(value);\n      }\n      this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) : 24;\n    }\n    if (changes.playTime) {\n      const value = changes.playTime.currentValue;\n      if (changes.playTime.currentValue instanceof String) {\n        this.playTime = new Date(value).getTime();\n      } else if (value instanceof Date) {\n        this.playTime = value.getTime();\n      } else if (typeof value === 'number') {\n        this.playTime = Number(value);\n      }\n      // use SetTimeOut Timer to make it  asynchronous\n      setTimeout(() => {\n        this.set_time_to_middle(new Date(this.playTime).getTime());\n      }, 100);\n    }\n    if (changes.speed) {\n      this.speed = Number(changes.speed.currentValue) * 1000;\n    }\n    if (changes.forWardValue) {\n      this.forWardValue = Number(changes.forWardValue.currentValue) * 1000;\n    }\n    if (changes.isPlayClick) {\n      if (changes.isPlayClick.currentValue) {\n        this.onPlayClick();\n      } else {\n        this.onPauseClick();\n      }\n    }\n  }\n  /**\n   * Initialize\n   * @param  startTimestamp Leftmost time\n   * @param  timecell Video segment array\n   * @param  redrawFlag Whether to redraw the mark\n   */\n  init(startTimestamp, timecell, redrawFlag) {\n    this.timecell = timecell;\n    this.startTimestamp = startTimestamp;\n    if (this.currentTimestamp >= this.endTimeThreshold) {\n      this.startTimestamp = Number(this.endTimeThreshold) - this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600;\n      this.currentTimestamp = Number(this.startTimestamp) + this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600;\n      this.playTime = Number(this.startTimestamp) + this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600;\n    } else if (this.currentTimestamp <= this.startTimeThreshold) {\n      this.startTimestamp = Number(this.startTimeThreshold) - this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600;\n      this.currentTimestamp = Number(this.startTimestamp) + this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600;\n      this.playTime = Number(this.startTimestamp) + this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600;\n    }\n    this.drawCellBg();\n    this.add_graduations(startTimestamp);\n    this.add_cells(timecell);\n    // Draw the verticalBar\n    this.drawLine(0, this.canvasH, this.canvasW, this.canvasH, this.bottomLineColor, 1);\n  }\n  /**\n   * Draw add scale\n   * @param  startTimestamp Leftmost time\n   */\n  add_graduations(startTimestamp) {\n    // px/min\n    const pxPerMin = this.canvasW / (this.hoursPerRuler * 60);\n    // px/ms\n    const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000);\n    // The default minimum value of PX/steo is 20px\n    let pxPerStep = this.graduationStep;\n    // Min/steo\n    let minPerStep = pxPerStep / pxPerMin;\n    for (const v of this.minutesPerStep) {\n      if (minPerStep <= v) {\n        // Keep each cell within the range specified by minutesPerStep\n        minPerStep = v;\n        pxPerStep = pxPerMin * minPerStep;\n        break;\n      }\n    }\n    let mediumStep = 30;\n    for (const v of this.minutesPerStep) {\n      if (this.distanceBetweenGtitle / pxPerMin <= v) {\n        mediumStep = v;\n        break;\n      }\n    }\n    // The total number\n    const numSteps = this.canvasW / pxPerStep;\n    let graduationLeft;\n    let graduationTime;\n    let caretClass;\n    let lineH;\n    // The initial offset time (ms)\n    const msOffset = this.ms_to_next_step(startTimestamp, minPerStep * 60 * 1000);\n    // The initial offset is (px)\n    const pxOffset = msOffset * pxPerMs;\n    // ms/step\n    const msPerStep = pxPerStep / pxPerMs;\n    for (let i = 0; i < numSteps; i++) {\n      // Distance = offset distance to start + steps *px/ steps\n      graduationLeft = pxOffset + i * pxPerStep;\n      // Time = left start time + offset time + steps *ms/ steps\n      graduationTime = Number(startTimestamp) + Number(msOffset) + i * Number(msPerStep);\n      const date = new Date(graduationTime);\n      if (date.getUTCHours() === 0 && date.getUTCMinutes() === 0) {\n        caretClass = 'big';\n        lineH = this.scale * 1.25;\n        const bigDate = DateUtil.formatDate(date, 'HH:mm:ss');\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(bigDate, graduationLeft, this.scale * 1.5);\n        this.ctx.fillStyle = this.verticalBarColor;\n      } else if (graduationTime / (60 * 1000) % mediumStep === 0) {\n        caretClass = 'middle';\n        lineH = this.scale * 0.75;\n        const middleDate = DateUtil.formatDate(date, 'HH:mm:ss');\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(middleDate, graduationLeft, this.scale * 1.5);\n        this.ctx.fillStyle = this.verticalBarColor;\n      } else {\n        lineH = this.scale * 0.5;\n      }\n      // drawLine(graduationLeft,0,graduationLeft,lineH,\"rgba(151,158,167,0.4)\",1);\n      this.drawLine(graduationLeft, 0, graduationLeft, lineH, this.verticalBarColor, 1);\n    }\n  }\n  /**\n   * Draw the play button\n   */\n  drawPalyBar() {\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.playBarOffsetX, 0);\n    this.ctx.lineTo(this.playBarOffsetX, this.scale * 1.75);\n    this.ctx.strokeStyle = this.playBarColor;\n    this.ctx.stroke();\n    this.ctx.moveTo(this.playBarOffsetX, this.scale * 1.75);\n    this.ctx.lineTo(this.playBarOffsetX, this.scale * 1.75);\n    this.ctx.lineTo(this.playBarOffsetX - this.scale * 0.6, this.scale * 2.5);\n    this.ctx.lineTo(this.playBarOffsetX - this.scale * 0.6, this.scale * 3.5);\n    this.ctx.lineTo(this.playBarOffsetX + this.scale * 0.6, this.scale * 3.5);\n    this.ctx.lineTo(this.playBarOffsetX + this.scale * 0.6, this.scale * 2.5);\n    this.ctx.lineTo(this.playBarOffsetX, this.scale * 1.75);\n    this.ctx.fillStyle = this.playBarColor;\n    this.ctx.fill();\n    this.ctx.closePath();\n    // this.init(this.startTimestamp, this.timecell, false);\n    const time = Number(this.currentTimestamp);\n    this.ctx.fillStyle = this.playBarColor;\n    this.ctx.textAlign = 'center';\n    this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), this.playBarOffsetX, this.scale * 4.25);\n  }\n  /**\n   * Draw the line\n   * @param  beginX The X-axis to start with\n   * @param  beginY The Y-axis to start with\n   * @param  endX The end of the X-axis\n   * @param  endY The end of the Y-axis\n   * @param  color color\n   * @param  width width\n   */\n  drawLine(beginX, beginY, endX, endY, color, width) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(beginX, beginY);\n    this.ctx.lineTo(endX, endY);\n    this.ctx.strokeStyle = color;\n    this.ctx.lineWidth = width;\n    this.ctx.stroke();\n  }\n  /**\n   * Add video segment\n   * @param  cells Video array\n   */\n  add_cells(cells) {\n    cells.forEach(cell => {\n      this.draw_cell(cell);\n    });\n  }\n  /**\n   * Draw video blocks\n   * @param  cell The cell includes beginTime Ms; The endTime ms; style;\n   */\n  draw_cell(cell) {\n    const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000); // px/ms\n    const beginX = (cell.beginTime - this.startTimestamp) * pxPerMs;\n    const cellWidth = (cell.endTime - cell.beginTime) * pxPerMs;\n    this.ctx.fillStyle = cell.style.background;\n    this.ctx.fillRect(beginX, 0, cellWidth, this.scale * 0.75);\n  }\n  /**\n   * Draws the background of the video block\n   */\n  drawCellBg() {\n    this.ctx.fillStyle = 'rgba(69, 72, 76, 0.5)';\n    this.ctx.fillRect(0, 0, this.canvasW, 0);\n  }\n  /**\n   * Drag/click the Mousedown event\n   */\n  mousedownFunc(e) {\n    this.gIsMousedown = true;\n    this.gMousedownCursor = this.get_cursor_x_position(e).posX;\n    this.gMousedownCursorY = this.get_cursor_x_position(e).posY;\n  }\n  /**\n   * Drag/mouse hover to display mousemove events\n   */\n  mousemoveFunc(e) {\n    this.clearCanvas();\n    const posX = this.get_cursor_x_position(e).posX;\n    const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n    const diffX = posX - this.gMousedownCursor;\n    if (this.gIsMousedown) {\n      if (this.gMousedownCursor >= this.playBarOffsetX1 && this.gMousedownCursor <= this.playBarOffsetX2 && this.gMousedownCursorY >= this.playBarOffsetY1 && this.gMousedownCursorY <= this.playBarOffsetY2) {\n        // this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n        // this.playBarOffsetX = posX;\n        // this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n        // this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n        this.startTimestamp = this.startTimestamp + Math.round(diffX / pxPerMs);\n        this.currentTimestamp = this.startTimestamp + Math.round(this.playBarOffsetX / pxPerMs);\n        this.drawPalyBar();\n        this.init(this.startTimestamp, this.timecell, false);\n        this.gIsMousemove = true;\n      } else {\n        this.startTimestamp = this.startTimestamp - Math.round(diffX / pxPerMs);\n        this.currentTimestamp = this.startTimestamp + Math.round(this.playBarOffsetX / pxPerMs);\n        this.drawPalyBar();\n        this.init(this.startTimestamp, this.timecell, true);\n        this.gIsMousemove = true;\n        this.gMousedownCursor = posX;\n      }\n      this.mouseUp.emit(this.currentTimestamp);\n    } else {\n      const time = this.startTimestamp + posX / pxPerMs;\n      this.drawPalyBar();\n      this.init(this.startTimestamp, this.timecell, true);\n      this.drawLine(posX, 0, posX, 50, 'rgb(194, 202, 215)', 1);\n      this.ctx.fillStyle = 'rgb(194, 202, 215)';\n      this.ctx.textAlign = 'center';\n      this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), posX, this.scale * 3);\n    }\n  }\n  /**\n   * Drag/click the Mouseup event\n   */\n  mouseupFunc(e) {\n    if (this.gIsMousemove) {\n      // Drag events\n      this.gIsMousemove = false;\n      this.gIsMousedown = false;\n      this.playTime = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n    } else {\n      // Click event\n      this.gIsMousedown = false;\n      // Mouse distance (px)\n      const posx = this.get_cursor_x_position(e).posX;\n      // ms/px\n      const msPerPx = this.zoom * 3600 * 1000 / this.canvasW;\n      this.playTime = this.startTimestamp + posx * msPerPx;\n      this.set_time_to_middle(this.playTime);\n    }\n    this.mouseDown.emit(this.playTime);\n  }\n  /**\n   * Mouseout of the hidden time mouseout event\n   */\n  mouseoutFunc() {\n    this.clearCanvas();\n    // px/ms\n    const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n    this.currentTimestamp = this.startTimestamp + Math.round(this.playBarOffsetX / pxPerMs);\n    this.drawPalyBar();\n    this.init(this.startTimestamp, this.timecell, true);\n  }\n  /**\n   * Scroll to the center of the timeline for the mousewheel event\n   */\n  mousewheelFunc(event) {\n    if (event && event.preventDefault) {\n      event.preventDefault();\n    } else {\n      window.event.returnValue = false;\n      return false;\n    }\n    const e = window.event || event;\n    const delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));\n    // Ms Remember the current middle time\n    const middleTime = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n    if (delta < 0) {\n      this.zoom = this.zoom + 4;\n      if (this.zoom >= 24) {\n        // Shrink to a minimum of 24 hours\n        this.zoom = 24;\n      }\n      this.hoursPerRuler = this.zoom;\n    } else if (delta > 0) {\n      // amplification\n      this.zoom = this.zoom - 4;\n      if (this.zoom <= 1) {\n        // Zoom in at most one hour\n        this.zoom = 1;\n      }\n      this.hoursPerRuler = this.zoom;\n    }\n    this.clearCanvas();\n    // // startTimestamp = current middle time - zoom /2\n    this.startTimestamp = middleTime - this.hoursPerRuler * 3600 * 1000 / 2;\n    this.init(this.startTimestamp, this.timecell, true);\n    this.drawPalyBar();\n  }\n  /**\n   * Get the mouse POSx\n   * @param  e event\n   */\n  get_cursor_x_position(e) {\n    let posx = 0;\n    let posy = 0;\n    if (!e) {\n      e = window.event;\n    }\n    if (e.offsetX || e.offsetY) {\n      posx = e.offsetX;\n      posy = e.offsetY;\n    }\n    return {\n      posX: posx,\n      posY: posy\n    };\n  }\n  /**\n   * The offset of the left start time, returns the unit ms\n   * @param  timestamp The time stamp\n   * @param  step The offset\n   */\n  ms_to_next_step(timestamp, step) {\n    const remainder = timestamp % step;\n    return remainder ? step - remainder : 0;\n  }\n  /**\n   * Set the time to jump to the middle red line\n   *  @param  time Unit of ms\n   */\n  set_time_to_middle(time) {\n    if (this.ctx) {\n      this.clearCanvas();\n      this.startTimestamp = time - this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n      this.currentTimestamp = time;\n      this.drawPalyBar();\n      this.init(this.startTimestamp, this.timecell, true);\n    }\n  }\n  /**\n   * 清除canvas 每次重新绘制需要先清除\n   */\n  clearCanvas() {\n    this.ctx.clearRect(0, 0, this.canvasW, this.scale * 7.5);\n  }\n  /**\n   * Click to play\n   */\n  onPlayClick() {\n    // this.setTimeMove = undefined;\n    this.isPlayClick = true;\n    this.setTimeMove = interval(this.speed).subscribe(d => {\n      this.playTime = Number(this.playTime) + 1 * 1000;\n      this.playClick.emit(this.playTime);\n      this.set_time_to_middle(this.playTime);\n    });\n  }\n  /**\n   * Click on the pause\n   */\n  onPauseClick() {\n    this.isPlayClick = false;\n    if (this.setTimeMove) {\n      // this.setTimeMove = undefined;\n      this.setTimeMove.unsubscribe();\n      this.playClick.emit(this.playTime);\n    }\n  }\n  /**\n   * Change video segment\n   */\n  changeVideo() {\n    const cells = [{\n      beginTime: new Date().getTime() - 1 * 1000 * 3600,\n      endTime: new Date().getTime() + 2 * 1000 * 3600,\n      style: {\n        background: 'rgba(132, 244, 180, 0.498039)'\n      }\n    }];\n    this.clearCanvas();\n    this.drawPalyBar();\n    this.init(this.startTimestamp, cells, true);\n  }\n  /**\n   * Temporary unused\n   * @param event MatDatepickerInputEvent(Date)\n   */\n  selectedTime(event) {\n    const timestamp = new Date(event.value.getTime());\n    this.set_time_to_middle(Number(timestamp));\n  }\n  /**\n   * Temporary unused\n   * @param event MouseEvent\n   */\n  onDragStart(e) {\n    e.preventDefault();\n    return false;\n  }\n}\nNgxVideoTimelineComponent.ɵfac = function NgxVideoTimelineComponent_Factory(t) {\n  return new (t || NgxVideoTimelineComponent)();\n};\nNgxVideoTimelineComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NgxVideoTimelineComponent,\n  selectors: [[\"ngx-video-timeline\"]],\n  viewQuery: function NgxVideoTimelineComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 7);\n    }\n    if (rf & 2) {\n      let _t;\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvasExp = _t.first);\n    }\n  },\n  hostBindings: function NgxVideoTimelineComponent_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"resize\", function NgxVideoTimelineComponent_resize_HostBindingHandler() {\n        return ctx.onResize();\n      }, false, i0.ɵɵresolveWindow)(\"keydown\", function NgxVideoTimelineComponent_keydown_HostBindingHandler($event) {\n        return ctx.onKeyDown($event);\n      }, false, i0.ɵɵresolveWindow)(\"keyup\", function NgxVideoTimelineComponent_keyup_HostBindingHandler($event) {\n        return ctx.onKeyUp($event);\n      }, false, i0.ɵɵresolveWindow);\n    }\n  },\n  inputs: {\n    canvasHeight: \"canvasHeight\",\n    playTime: \"playTime\",\n    speed: \"speed\",\n    forWardValue: \"forWardValue\",\n    startTimeThreshold: \"startTimeThreshold\",\n    endTimeThreshold: \"endTimeThreshold\",\n    borderColor: \"borderColor\",\n    bgColor: \"bgColor\",\n    bottomLineColor: \"bottomLineColor\",\n    verticalBarColor: \"verticalBarColor\",\n    playBarColor: \"playBarColor\",\n    videoCells: \"videoCells\",\n    isPlayClick: \"isPlayClick\"\n  },\n  outputs: {\n    playClick: \"playClick\",\n    mouseUp: \"mouseUp\",\n    mouseDown: \"mouseDown\",\n    keyUp: \"keyUp\",\n    keyDown: \"keyDown\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature],\n  decls: 2,\n  vars: 4,\n  consts: [[1, \"canvas\", 3, \"ngStyle\", \"dragstart\", \"mouseup\", \"mousewheel\", \"mousedown\", \"mousemove\", \"mouseout\"], [\"timeline\", \"\"]],\n  template: function NgxVideoTimelineComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"canvas\", 0, 1);\n      i0.ɵɵlistener(\"dragstart\", function NgxVideoTimelineComponent_Template_canvas_dragstart_0_listener($event) {\n        return ctx.onDragStart($event);\n      })(\"mouseup\", function NgxVideoTimelineComponent_Template_canvas_mouseup_0_listener($event) {\n        return ctx.mouseupFunc($event);\n      })(\"mousewheel\", function NgxVideoTimelineComponent_Template_canvas_mousewheel_0_listener($event) {\n        return ctx.mousewheelFunc($event);\n      })(\"mousedown\", function NgxVideoTimelineComponent_Template_canvas_mousedown_0_listener($event) {\n        return ctx.mousedownFunc($event);\n      })(\"mousemove\", function NgxVideoTimelineComponent_Template_canvas_mousemove_0_listener($event) {\n        return ctx.mousemoveFunc($event);\n      })(\"mouseout\", function NgxVideoTimelineComponent_Template_canvas_mouseout_0_listener() {\n        return ctx.mouseoutFunc();\n      });\n      i0.ɵɵelementEnd();\n    }\n    if (rf & 2) {\n      i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction2(1, _c1, ctx.borderColor, ctx.bgColor));\n    }\n  },\n  directives: [i1.NgStyle],\n  styles: [\".canvas[_ngcontent-%COMP%]{width:100%;height:100%}\"]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxVideoTimelineComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-video-timeline',\n      template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\",\n      styles: [\".canvas{width:100%;height:100%}\\n\"]\n    }]\n  }], function () {\n    return [];\n  }, {\n    canvasHeight: [{\n      type: Input\n    }],\n    playTime: [{\n      type: Input\n    }],\n    speed: [{\n      type: Input\n    }],\n    forWardValue: [{\n      type: Input\n    }],\n    startTimeThreshold: [{\n      type: Input\n    }],\n    endTimeThreshold: [{\n      type: Input\n    }],\n    borderColor: [{\n      type: Input\n    }],\n    bgColor: [{\n      type: Input\n    }],\n    bottomLineColor: [{\n      type: Input\n    }],\n    verticalBarColor: [{\n      type: Input\n    }],\n    playBarColor: [{\n      type: Input\n    }],\n    videoCells: [{\n      type: Input\n    }],\n    isPlayClick: [{\n      type: Input\n    }],\n    playClick: [{\n      type: Output\n    }],\n    mouseUp: [{\n      type: Output\n    }],\n    mouseDown: [{\n      type: Output\n    }],\n    keyUp: [{\n      type: Output\n    }],\n    keyDown: [{\n      type: Output\n    }],\n    canvasExp: [{\n      type: ViewChild,\n      args: ['timeline', {\n        static: true\n      }]\n    }],\n    onResize: [{\n      type: HostListener,\n      args: ['window:resize', []]\n    }],\n    onKeyDown: [{\n      type: HostListener,\n      args: ['window:keydown', ['$event']]\n    }],\n    onKeyUp: [{\n      type: HostListener,\n      args: ['window:keyup', ['$event']]\n    }]\n  });\n})();\nclass NgxVideoTimelineModule {}\nNgxVideoTimelineModule.ɵfac = function NgxVideoTimelineModule_Factory(t) {\n  return new (t || NgxVideoTimelineModule)();\n};\nNgxVideoTimelineModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxVideoTimelineModule\n});\nNgxVideoTimelineModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxVideoTimelineModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NgxVideoTimelineComponent],\n      imports: [CommonModule],\n      exports: [NgxVideoTimelineComponent]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of timeline\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DateUtil, NgxVideoTimelineComponent, NgxVideoTimelineModule };","map":{"version":3,"names":["i0","EventEmitter","Component","Input","Output","ViewChild","HostListener","NgModule","interval","i1","CommonModule","_c0","_c1","a2","a3","cursor","border","borderColor","DateUtil","formatDate","date","format","year","getFullYear","toString","month","getMonth","padStart","day","getDate","hours","getHours","minutes","getMinutes","seconds","getSeconds","replace","NgxVideoTimelineComponent","constructor","canvasHeight","scale","gMousedownCursor","undefined","gMousedownCursorY","forWardValue","speed","playTime","Date","getTime","startTimeThreshold","endTimeThreshold","playClick","mouseUp","mouseDown","keyUp","keyDown","isPlayClick","videoCells","beginTime","endTime","style","background","verticalBarColor","bottomLineColor","bgColor","playBarColor","onResize","canvas","width","Math","round","parentNode","offsetWidth","canvasW","init","startTimestamp","timecell","onKeyDown","event","Number","keyCode","currentTimestamp","set_time_to_middle","emit","onKeyUp","onPauseClick","onPlayClick","ngOnInit","canvasExp","nativeElement","ctx","getContext","height","canvasH","minutesPerStep","graduationStep","hoursPerRuler","ceil","distanceBetweenGtitle","zoom","gIsMousedown","gIsMousemove","pxPerMs","playBarOffsetX","playBarDistanceLeft","playBarOffsetX1","playBarOffsetX2","playBarOffsetY1","playBarOffsetY2","drawPalyBar","ngOnChanges","changes","currentValue","add_cells","value","String","setTimeout","redrawFlag","drawCellBg","add_graduations","drawLine","pxPerMin","pxPerStep","minPerStep","v","mediumStep","numSteps","graduationLeft","graduationTime","caretClass","lineH","msOffset","ms_to_next_step","pxOffset","msPerStep","i","getUTCHours","getUTCMinutes","bigDate","textAlign","fillText","fillStyle","middleDate","beginPath","moveTo","lineTo","strokeStyle","stroke","fill","closePath","time","beginX","beginY","endX","endY","color","lineWidth","cells","forEach","cell","draw_cell","cellWidth","fillRect","mousedownFunc","e","get_cursor_x_position","posX","posY","mousemoveFunc","clearCanvas","diffX","mouseupFunc","posx","msPerPx","mouseoutFunc","mousewheelFunc","preventDefault","window","returnValue","delta","max","min","wheelDelta","detail","middleTime","posy","offsetX","offsetY","timestamp","step","remainder","clearRect","setTimeMove","subscribe","d","unsubscribe","changeVideo","selectedTime","onDragStart","ɵfac","NgxVideoTimelineComponent_Factory","t","ɵcmp","ɵɵdefineComponent","type","selectors","viewQuery","NgxVideoTimelineComponent_Query","rf","ɵɵviewQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","first","hostBindings","NgxVideoTimelineComponent_HostBindings","ɵɵlistener","NgxVideoTimelineComponent_resize_HostBindingHandler","ɵɵresolveWindow","NgxVideoTimelineComponent_keydown_HostBindingHandler","$event","NgxVideoTimelineComponent_keyup_HostBindingHandler","inputs","outputs","features","ɵɵNgOnChangesFeature","decls","vars","consts","template","NgxVideoTimelineComponent_Template","ɵɵelementStart","NgxVideoTimelineComponent_Template_canvas_dragstart_0_listener","NgxVideoTimelineComponent_Template_canvas_mouseup_0_listener","NgxVideoTimelineComponent_Template_canvas_mousewheel_0_listener","NgxVideoTimelineComponent_Template_canvas_mousedown_0_listener","NgxVideoTimelineComponent_Template_canvas_mousemove_0_listener","NgxVideoTimelineComponent_Template_canvas_mouseout_0_listener","ɵɵelementEnd","ɵɵproperty","ɵɵpureFunction2","directives","NgStyle","styles","ngDevMode","ɵsetClassMetadata","args","selector","static","NgxVideoTimelineModule","NgxVideoTimelineModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports","declarations","exports"],"sources":["/Users/mac/lenon/repositories/ngx-video-timeline/node_modules/ngx-video-timeline/fesm2015/ngx-video-timeline.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, Output, ViewChild, HostListener, NgModule } from '@angular/core';\nimport { interval } from 'rxjs';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * A utility class for working with dates.\n */\nclass DateUtil {\n    /**\n     * Formats the given date according to the specified format.\n     * @param date The date to format.\n     * @param format The format string, using the following placeholders:\n     *   - YYYY: four-digit year\n     *   - MM: two-digit month (zero-padded)\n     *   - DD: two-digit day of month (zero-padded)\n     *   - HH: two-digit hour (zero-padded, 24-hour format)\n     *   - mm: two-digit minute (zero-padded)\n     *   - ss: two-digit second (zero-padded)\n     * @returns The formatted date string.\n     */\n    static formatDate(date, format) {\n        // Extract the year, month, day, hours, minutes, and seconds from the date\n        const year = date.getFullYear().toString();\n        const month = (date.getMonth() + 1).toString().padStart(2, '0');\n        const day = date.getDate().toString().padStart(2, '0');\n        const hours = date.getHours().toString().padStart(2, '0');\n        const minutes = date.getMinutes().toString().padStart(2, '0');\n        const seconds = date.getSeconds().toString().padStart(2, '0');\n        // Replace the placeholders in the format string with the corresponding date parts\n        return format\n            .replace('YYYY', year)\n            .replace('MM', month)\n            .replace('DD', day)\n            .replace('HH', hours)\n            .replace('mm', minutes)\n            .replace('ss', seconds);\n    }\n}\nclass NgxVideoTimelineComponent {\n    constructor() {\n        // The height of the outer canvas\n        this.canvasHeight = 50;\n        // Canvas scale is adjusted according to outer height\n        this.scale = this.canvasHeight / 4.55;\n        // The position of the X-axis when the mouse is pressed\n        this.gMousedownCursor = undefined;\n        // The position of the y-axis when the mouse is pressed\n        this.gMousedownCursorY = undefined;\n        // this.startTimeThreshold = new Date().getTime() - 1 * 0.5 * 3600 * 1000;\n        // this.endTimeThreshold = new Date().getTime() + 1 * 1 * 3600 * 1000;\n        this.forWardValue = 5000;\n        this.speed = 1000;\n        this.playTime = new Date().getTime();\n        this.startTimeThreshold = new Date().getTime() - 1 * 12 * 3600 * 1000;\n        this.endTimeThreshold = new Date().getTime() + 1 * 12 * 3600 * 1000;\n        this.playClick = new EventEmitter();\n        this.mouseUp = new EventEmitter();\n        this.mouseDown = new EventEmitter();\n        this.keyUp = new EventEmitter();\n        this.keyDown = new EventEmitter();\n        this.isPlayClick = false;\n        this.videoCells = [\n            {\n                beginTime: new Date().getTime() - 3 * 3600 * 1000,\n                endTime: new Date().getTime() - 1 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            },\n            {\n                beginTime: new Date().getTime() - 6 * 3600 * 1000,\n                endTime: new Date().getTime() - 4 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.verticalBarColor = 'rgba(0,0,0,1)';\n        this.bottomLineColor = 'rgba(0,0,0,1)';\n        this.borderColor = '#fff';\n        this.bgColor = '#fff';\n        this.playBarColor = '#448aff';\n    }\n    /**\n     * Browser change event\n     */\n    onResize() {\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        this.canvasW = this.canvas.parentNode.offsetWidth;\n        this.init(this.startTimestamp, this.timecell, false);\n    }\n    /**\n     * Keyboard press event\n     */\n    onKeyDown(event) {\n        if (Number(event.keyCode) === 37) {\n            this.playTime = Number(this.playTime) - this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) - this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        else if (Number(event.keyCode === 39)) {\n            this.playTime = Number(this.playTime) + this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) + this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.keyDown.emit(this.playTime);\n    }\n    /**\n     * Keyboard release event\n     */\n    onKeyUp(event) {\n        if (Number(event.keyCode) === 13 || Number(event.keyCode === 32)) {\n            this.isPlayClick ? this.onPauseClick() : this.onPlayClick();\n        }\n        this.keyUp.emit(this.playTime);\n    }\n    ngOnInit() {\n        // Initialize data video group event stamp to show new Date().getTime()- number of hours\n        // Assign the Canvas DOM to the variable Canvas\n        this.canvas = this.canvasExp.nativeElement;\n        // Define the area of the canvas\n        this.ctx = this.canvas.getContext('2d');\n        // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        // Store the width and height of the canvas\n        this.canvasW = this.canvas.width;\n        this.canvas.height = this.canvasHeight;\n        this.canvasH = this.canvas.height;\n        // Assign the video array to Timecell\n        this.timecell = this.videoCells;\n        // Initialize the number of steps per minute\n        this.minutesPerStep = [\n            1,\n            2,\n            5,\n            10,\n            15,\n            20,\n            30,\n            60,\n            120,\n            180,\n            240,\n            360,\n            720,\n            1440\n        ];\n        // Initialization style\n        // Minimum width between scales, in units of px 20px\n        this.graduationStep = 20;\n        // The timeline shows the time rounded up according to the time threshold\n        this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n            Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) :\n            24;\n        // The leftmost timestamp defaults to 12 hours before the current time\n        this.startTimestamp = Number(this.startTimeThreshold);\n        // Default distance 80\n        this.distanceBetweenGtitle = 80;\n        // Default zoom 24\n        this.zoom = 24;\n        // Default false\n        this.gIsMousedown = false;\n        this.gIsMousemove = false;\n        this.gMousedownCursor = undefined;\n        // px/ms\n        this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        // The initial X position of the playback icon is in the middle of the scale\n        this.playBarOffsetX = this.canvasW / 2;\n        this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n        this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n        this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n        this.playBarOffsetY1 = (this.scale * 2.5);\n        this.playBarOffsetY2 = ((this.scale * 3.5));\n        // Initialize the timeline\n        this.init(this.startTimestamp, this.timecell, false);\n        // Draw the play button\n        this.drawPalyBar();\n    }\n    ngOnChanges(changes) {\n        // Refactor the playback component when the width and height change\n        if (changes.canvasHeight) {\n            this.canvasHeight = changes.canvasHeight.currentValue;\n            // Assign the Canvas DOM to the variable Canvas\n            this.canvas = this.canvasExp.nativeElement;\n            // Define the area of the canvas\n            this.ctx = this.canvas.getContext('2d');\n            // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n            this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n            // Store the width and height of the canvas\n            this.canvasW = this.canvas.width;\n            this.canvas.height = this.canvasHeight;\n            this.canvasH = this.canvas.height;\n            // Assign the video array to Timecell\n            this.timecell = this.videoCells;\n            this.minutesPerStep = [\n                1,\n                2,\n                5,\n                10,\n                15,\n                20,\n                30,\n                60,\n                120,\n                180,\n                240,\n                360,\n                720,\n                1440\n            ];\n            // The timeline shows the time rounded up according to the time threshold\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n                Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            // The leftmost timestamp defaults to 12 hours before the current time\n            this.startTimestamp = Number(this.startTimeThreshold);\n            this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n            // The initial X position of the playback icon is in the middle of the scale\n            this.playBarOffsetX = this.canvasW / 2;\n            this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n            // Current timestamp\n            this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n            this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n            this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n            this.playBarOffsetY1 = (this.scale * 2.5);\n            this.playBarOffsetY2 = ((this.scale * 3.5));\n            this.init(this.startTimestamp, this.timecell, false);\n            this.drawPalyBar();\n        }\n        if (changes.videoCells) {\n            this.videoCells = changes.videoCells.currentValue;\n            this.timecell = this.videoCells;\n            this.add_cells(this.timecell);\n            // this.init(this.startTimestamp, this.timecell, true);\n            // this.drawPalyBar();\n        }\n        if (changes.startTimeThreshold) {\n            const value = changes.startTimeThreshold.currentValue;\n            if (changes.startTimeThreshold.currentValue instanceof String) {\n                this.startTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.startTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.startTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            this.startTimestamp = Number(this.startTimeThreshold);\n            // this.init(this.startTimestamp, this.timecell, false);\n        }\n        if (changes.endTimeThreshold) {\n            const value = changes.endTimeThreshold.currentValue;\n            if (changes.endTimeThreshold.currentValue instanceof String) {\n                this.endTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.endTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.endTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n        }\n        if (changes.playTime) {\n            const value = changes.playTime.currentValue;\n            if (changes.playTime.currentValue instanceof String) {\n                this.playTime = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.playTime = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.playTime = Number(value);\n            }\n            // use SetTimeOut Timer to make it  asynchronous\n            setTimeout(() => {\n                this.set_time_to_middle(new Date(this.playTime).getTime());\n            }, 100);\n        }\n        if (changes.speed) {\n            this.speed = Number(changes.speed.currentValue) * 1000;\n        }\n        if (changes.forWardValue) {\n            this.forWardValue = Number(changes.forWardValue.currentValue) * 1000;\n        }\n        if (changes.isPlayClick) {\n            if (changes.isPlayClick.currentValue) {\n                this.onPlayClick();\n            }\n            else {\n                this.onPauseClick();\n            }\n        }\n    }\n    /**\n     * Initialize\n     * @param  startTimestamp Leftmost time\n     * @param  timecell Video segment array\n     * @param  redrawFlag Whether to redraw the mark\n     */\n    init(startTimestamp, timecell, redrawFlag) {\n        this.timecell = timecell;\n        this.startTimestamp = startTimestamp;\n        if (this.currentTimestamp >=\n            this.endTimeThreshold) {\n            this.startTimestamp =\n                Number(this.endTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        else if (this.currentTimestamp <=\n            this.startTimeThreshold) {\n            this.startTimestamp =\n                Number(this.startTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        this.drawCellBg();\n        this.add_graduations(startTimestamp);\n        this.add_cells(timecell);\n        // Draw the verticalBar\n        this.drawLine(0, this.canvasH, this.canvasW, this.canvasH, this.bottomLineColor, 1);\n    }\n    /**\n     * Draw add scale\n     * @param  startTimestamp Leftmost time\n     */\n    add_graduations(startTimestamp) {\n        // px/min\n        const pxPerMin = this.canvasW / (this.hoursPerRuler * 60);\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000);\n        // The default minimum value of PX/steo is 20px\n        let pxPerStep = this.graduationStep;\n        // Min/steo\n        let minPerStep = pxPerStep / pxPerMin;\n        for (const v of this.minutesPerStep) {\n            if (minPerStep <= v) {\n                // Keep each cell within the range specified by minutesPerStep\n                minPerStep = v;\n                pxPerStep = pxPerMin * minPerStep;\n                break;\n            }\n        }\n        let mediumStep = 30;\n        for (const v of this.minutesPerStep) {\n            if (this.distanceBetweenGtitle / pxPerMin <= v) {\n                mediumStep = v;\n                break;\n            }\n        }\n        // The total number\n        const numSteps = this.canvasW / pxPerStep;\n        let graduationLeft;\n        let graduationTime;\n        let caretClass;\n        let lineH;\n        // The initial offset time (ms)\n        const msOffset = this.ms_to_next_step(startTimestamp, minPerStep * 60 * 1000);\n        // The initial offset is (px)\n        const pxOffset = msOffset * pxPerMs;\n        // ms/step\n        const msPerStep = pxPerStep / pxPerMs;\n        for (let i = 0; i < numSteps; i++) {\n            // Distance = offset distance to start + steps *px/ steps\n            graduationLeft = pxOffset + i * pxPerStep;\n            // Time = left start time + offset time + steps *ms/ steps\n            graduationTime =\n                Number(startTimestamp) +\n                    Number(msOffset) +\n                    i * Number(msPerStep);\n            const date = new Date(graduationTime);\n            if (date.getUTCHours() === 0 && date.getUTCMinutes() === 0) {\n                caretClass = 'big';\n                lineH = (this.scale * 1.25);\n                const bigDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(bigDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else if ((graduationTime / (60 * 1000)) % mediumStep === 0) {\n                caretClass = 'middle';\n                lineH = (this.scale * 0.75);\n                const middleDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(middleDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else {\n                lineH = (this.scale * 0.5);\n            }\n            // drawLine(graduationLeft,0,graduationLeft,lineH,\"rgba(151,158,167,0.4)\",1);\n            this.drawLine(graduationLeft, 0, graduationLeft, lineH, this.verticalBarColor, 1);\n        }\n    }\n    /**\n     * Draw the play button\n     */\n    drawPalyBar() {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.playBarOffsetX, 0);\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.strokeStyle = this.playBarColor;\n        this.ctx.stroke();\n        this.ctx.moveTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.fill();\n        this.ctx.closePath();\n        // this.init(this.startTimestamp, this.timecell, false);\n        const time = Number(this.currentTimestamp);\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), this.playBarOffsetX, (this.scale * 4.25));\n    }\n    /**\n     * Draw the line\n     * @param  beginX The X-axis to start with\n     * @param  beginY The Y-axis to start with\n     * @param  endX The end of the X-axis\n     * @param  endY The end of the Y-axis\n     * @param  color color\n     * @param  width width\n     */\n    drawLine(beginX, beginY, endX, endY, color, width) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(beginX, beginY);\n        this.ctx.lineTo(endX, endY);\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = width;\n        this.ctx.stroke();\n    }\n    /**\n     * Add video segment\n     * @param  cells Video array\n     */\n    add_cells(cells) {\n        cells.forEach((cell) => {\n            this.draw_cell(cell);\n        });\n    }\n    /**\n     * Draw video blocks\n     * @param  cell The cell includes beginTime Ms; The endTime ms; style;\n     */\n    draw_cell(cell) {\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000); // px/ms\n        const beginX = (cell.beginTime - this.startTimestamp) * pxPerMs;\n        const cellWidth = (cell.endTime - cell.beginTime) * pxPerMs;\n        this.ctx.fillStyle = cell.style.background;\n        this.ctx.fillRect(beginX, 0, cellWidth, (this.scale * 0.75));\n    }\n    /**\n     * Draws the background of the video block\n     */\n    drawCellBg() {\n        this.ctx.fillStyle = 'rgba(69, 72, 76, 0.5)';\n        this.ctx.fillRect(0, 0, this.canvasW, 0);\n    }\n    /**\n     * Drag/click the Mousedown event\n     */\n    mousedownFunc(e) {\n        this.gIsMousedown = true;\n        this.gMousedownCursor = this.get_cursor_x_position(e).posX;\n        this.gMousedownCursorY = this.get_cursor_x_position(e).posY;\n    }\n    /**\n     * Drag/mouse hover to display mousemove events\n     */\n    mousemoveFunc(e) {\n        this.clearCanvas();\n        const posX = this.get_cursor_x_position(e).posX;\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        const diffX = posX - this.gMousedownCursor;\n        if (this.gIsMousedown) {\n            if (this.gMousedownCursor >= this.playBarOffsetX1 &&\n                this.gMousedownCursor <= this.playBarOffsetX2 &&\n                this.gMousedownCursorY >= this.playBarOffsetY1 &&\n                this.gMousedownCursorY <= this.playBarOffsetY2) {\n                // this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n                // this.playBarOffsetX = posX;\n                // this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n                // this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n                this.startTimestamp =\n                    this.startTimestamp + Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    (this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs));\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, false);\n                this.gIsMousemove = true;\n            }\n            else {\n                this.startTimestamp =\n                    this.startTimestamp - Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs);\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, true);\n                this.gIsMousemove = true;\n                this.gMousedownCursor = posX;\n            }\n            this.mouseUp.emit(this.currentTimestamp);\n        }\n        else {\n            const time = this.startTimestamp + posX / pxPerMs;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n            this.drawLine(posX, 0, posX, 50, 'rgb(194, 202, 215)', 1);\n            this.ctx.fillStyle = 'rgb(194, 202, 215)';\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), posX, (this.scale * 3));\n        }\n    }\n    /**\n     * Drag/click the Mouseup event\n     */\n    mouseupFunc(e) {\n        if (this.gIsMousemove) {\n            // Drag events\n            this.gIsMousemove = false;\n            this.gIsMousedown = false;\n            this.playTime =\n                this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        }\n        else {\n            // Click event\n            this.gIsMousedown = false;\n            // Mouse distance (px)\n            const posx = this.get_cursor_x_position(e).posX;\n            // ms/px\n            const msPerPx = (this.zoom * 3600 * 1000) / this.canvasW;\n            this.playTime = this.startTimestamp + posx * msPerPx;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.mouseDown.emit(this.playTime);\n    }\n    /**\n     * Mouseout of the hidden time mouseout event\n     */\n    mouseoutFunc() {\n        this.clearCanvas();\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        this.currentTimestamp =\n            this.startTimestamp +\n                Math.round(this.playBarOffsetX / pxPerMs);\n        this.drawPalyBar();\n        this.init(this.startTimestamp, this.timecell, true);\n    }\n    /**\n     * Scroll to the center of the timeline for the mousewheel event\n     */\n    mousewheelFunc(event) {\n        if (event && event.preventDefault) {\n            event.preventDefault();\n        }\n        else {\n            window.event.returnValue = false;\n            return false;\n        }\n        const e = window.event || event;\n        const delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));\n        // Ms Remember the current middle time\n        const middleTime = this.startTimestamp + (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n        if (delta < 0) {\n            this.zoom = this.zoom + 4;\n            if (this.zoom >= 24) {\n                // Shrink to a minimum of 24 hours\n                this.zoom = 24;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        else if (delta > 0) {\n            // amplification\n            this.zoom = this.zoom - 4;\n            if (this.zoom <= 1) {\n                // Zoom in at most one hour\n                this.zoom = 1;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        this.clearCanvas();\n        // // startTimestamp = current middle time - zoom /2\n        this.startTimestamp =\n            middleTime - (this.hoursPerRuler * 3600 * 1000) / 2;\n        this.init(this.startTimestamp, this.timecell, true);\n        this.drawPalyBar();\n    }\n    /**\n     * Get the mouse POSx\n     * @param  e event\n     */\n    get_cursor_x_position(e) {\n        let posx = 0;\n        let posy = 0;\n        if (!e) {\n            e = window.event;\n        }\n        if (e.offsetX || e.offsetY) {\n            posx = e.offsetX;\n            posy = e.offsetY;\n        }\n        return { posX: posx, posY: posy };\n    }\n    /**\n     * The offset of the left start time, returns the unit ms\n     * @param  timestamp The time stamp\n     * @param  step The offset\n     */\n    ms_to_next_step(timestamp, step) {\n        const remainder = timestamp % step;\n        return remainder ? step - remainder : 0;\n    }\n    /**\n     * Set the time to jump to the middle red line\n     *  @param  time Unit of ms\n     */\n    set_time_to_middle(time) {\n        if (this.ctx) {\n            this.clearCanvas();\n            this.startTimestamp = time - (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n            this.currentTimestamp = time;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n        }\n    }\n    /**\n     * 清除canvas 每次重新绘制需要先清除\n     */\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.canvasW, (this.scale * 7.5));\n    }\n    /**\n     * Click to play\n     */\n    onPlayClick() {\n        // this.setTimeMove = undefined;\n        this.isPlayClick = true;\n        this.setTimeMove = interval(this.speed).subscribe((d) => {\n            this.playTime = Number(this.playTime) + 1 * 1000;\n            this.playClick.emit(this.playTime);\n            this.set_time_to_middle(this.playTime);\n        });\n    }\n    /**\n     * Click on the pause\n     */\n    onPauseClick() {\n        this.isPlayClick = false;\n        if (this.setTimeMove) {\n            // this.setTimeMove = undefined;\n            this.setTimeMove.unsubscribe();\n            this.playClick.emit(this.playTime);\n        }\n    }\n    /**\n     * Change video segment\n     */\n    changeVideo() {\n        const cells = [\n            {\n                beginTime: new Date().getTime() - 1 * 1000 * 3600,\n                endTime: new Date().getTime() + 2 * 1000 * 3600,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.clearCanvas();\n        this.drawPalyBar();\n        this.init(this.startTimestamp, cells, true);\n    }\n    /**\n     * Temporary unused\n     * @param event MatDatepickerInputEvent(Date)\n     */\n    selectedTime(event) {\n        const timestamp = new Date(event.value.getTime());\n        this.set_time_to_middle(Number(timestamp));\n    }\n    /**\n     * Temporary unused\n     * @param event MouseEvent\n     */\n    onDragStart(e) {\n        e.preventDefault();\n        return false;\n    }\n}\nNgxVideoTimelineComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.4.0\", ngImport: i0, type: NgxVideoTimelineComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nNgxVideoTimelineComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.4.0\", type: NgxVideoTimelineComponent, selector: \"ngx-video-timeline\", inputs: { canvasHeight: \"canvasHeight\", playTime: \"playTime\", speed: \"speed\", forWardValue: \"forWardValue\", startTimeThreshold: \"startTimeThreshold\", endTimeThreshold: \"endTimeThreshold\", borderColor: \"borderColor\", bgColor: \"bgColor\", bottomLineColor: \"bottomLineColor\", verticalBarColor: \"verticalBarColor\", playBarColor: \"playBarColor\", videoCells: \"videoCells\", isPlayClick: \"isPlayClick\" }, outputs: { playClick: \"playClick\", mouseUp: \"mouseUp\", mouseDown: \"mouseDown\", keyUp: \"keyUp\", keyDown: \"keyDown\" }, host: { listeners: { \"window:resize\": \"onResize()\", \"window:keydown\": \"onKeyDown($event)\", \"window:keyup\": \"onKeyUp($event)\" } }, viewQueries: [{ propertyName: \"canvasExp\", first: true, predicate: [\"timeline\"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"], directives: [{ type: i1.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.4.0\", ngImport: i0, type: NgxVideoTimelineComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-video-timeline', template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"] }]\n        }], ctorParameters: function () { return []; }, propDecorators: { canvasHeight: [{\n                type: Input\n            }], playTime: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], forWardValue: [{\n                type: Input\n            }], startTimeThreshold: [{\n                type: Input\n            }], endTimeThreshold: [{\n                type: Input\n            }], borderColor: [{\n                type: Input\n            }], bgColor: [{\n                type: Input\n            }], bottomLineColor: [{\n                type: Input\n            }], verticalBarColor: [{\n                type: Input\n            }], playBarColor: [{\n                type: Input\n            }], videoCells: [{\n                type: Input\n            }], isPlayClick: [{\n                type: Input\n            }], playClick: [{\n                type: Output\n            }], mouseUp: [{\n                type: Output\n            }], mouseDown: [{\n                type: Output\n            }], keyUp: [{\n                type: Output\n            }], keyDown: [{\n                type: Output\n            }], canvasExp: [{\n                type: ViewChild,\n                args: ['timeline', { static: true }]\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }], onKeyDown: [{\n                type: HostListener,\n                args: ['window:keydown', ['$event']]\n            }], onKeyUp: [{\n                type: HostListener,\n                args: ['window:keyup', ['$event']]\n            }] } });\n\nclass NgxVideoTimelineModule {\n}\nNgxVideoTimelineModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.4.0\", ngImport: i0, type: NgxVideoTimelineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxVideoTimelineModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.4.0\", ngImport: i0, type: NgxVideoTimelineModule, declarations: [NgxVideoTimelineComponent], imports: [CommonModule], exports: [NgxVideoTimelineComponent] });\nNgxVideoTimelineModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.4.0\", ngImport: i0, type: NgxVideoTimelineModule, imports: [[\n            CommonModule\n        ]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.4.0\", ngImport: i0, type: NgxVideoTimelineModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [NgxVideoTimelineComponent],\n                    imports: [\n                        CommonModule\n                    ],\n                    exports: [NgxVideoTimelineComponent]\n                }]\n        }] });\n\n/*\n * Public API Surface of timeline\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DateUtil, NgxVideoTimelineComponent, NgxVideoTimelineModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}