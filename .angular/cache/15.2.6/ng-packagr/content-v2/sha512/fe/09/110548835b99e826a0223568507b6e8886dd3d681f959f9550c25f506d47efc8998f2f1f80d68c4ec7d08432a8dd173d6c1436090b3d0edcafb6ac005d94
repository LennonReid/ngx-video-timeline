{"hash":"729a9192714b58bb63ab8f807f7be04b1965b88a","fesm2020":[{"exports":["DateUtil","NgxVideoTimelineComponent","NgxVideoTimelineModule"],"facadeModuleId":"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/ngx-video-timeline.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/lib/timeline.component.mjs","/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/lib/timeline.module.mjs","/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/public-api.mjs","/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/ngx-video-timeline.mjs"],"name":"ngx-video-timeline","type":"chunk","dynamicImports":[],"fileName":"ngx-video-timeline.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["EventEmitter","*","Component","Input","Output","ViewChild","HostListener","NgModule"],"rxjs":["interval"],"@angular/common":["*","CommonModule"]},"imports":["@angular/core","rxjs","@angular/common"],"modules":{"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/lib/timeline.component.mjs":{"code":"/**\n * A utility class for working with dates.\n */\nclass DateUtil {\n    /**\n     * Formats the given date according to the specified format.\n     * @param date The date to format.\n     * @param format The format string, using the following placeholders:\n     *   - YYYY: four-digit year\n     *   - MM: two-digit month (zero-padded)\n     *   - DD: two-digit day of month (zero-padded)\n     *   - HH: two-digit hour (zero-padded, 24-hour format)\n     *   - mm: two-digit minute (zero-padded)\n     *   - ss: two-digit second (zero-padded)\n     * @returns The formatted date string.\n     */\n    static formatDate(date, format) {\n        // Extract the year, month, day, hours, minutes, and seconds from the date\n        const year = date.getFullYear().toString();\n        const month = (date.getMonth() + 1).toString().padStart(2, '0');\n        const day = date.getDate().toString().padStart(2, '0');\n        const hours = date.getHours().toString().padStart(2, '0');\n        const minutes = date.getMinutes().toString().padStart(2, '0');\n        const seconds = date.getSeconds().toString().padStart(2, '0');\n        // Replace the placeholders in the format string with the corresponding date parts\n        return format\n            .replace('YYYY', year)\n            .replace('MM', month)\n            .replace('DD', day)\n            .replace('HH', hours)\n            .replace('mm', minutes)\n            .replace('ss', seconds);\n    }\n}\nclass NgxVideoTimelineComponent {\n    constructor() {\n        // The height of the outer canvas\n        this.canvasHeight = 50;\n        // Canvas scale is adjusted according to outer height\n        this.scale = this.canvasHeight / 4.55;\n        // The position of the X-axis when the mouse is pressed\n        this.gMousedownCursor = undefined;\n        // The position of the y-axis when the mouse is pressed\n        this.gMousedownCursorY = undefined;\n        // this.startTimeThreshold = new Date().getTime() - 1 * 0.5 * 3600 * 1000;\n        // this.endTimeThreshold = new Date().getTime() + 1 * 1 * 3600 * 1000;\n        this.forWardValue = 5000;\n        this.speed = 1000;\n        this.playTime = new Date().getTime();\n        this.startTimeThreshold = new Date().getTime() - 1 * 12 * 3600 * 1000;\n        this.endTimeThreshold = new Date().getTime() + 1 * 12 * 3600 * 1000;\n        this.playClick = new EventEmitter();\n        this.mouseUp = new EventEmitter();\n        this.mouseDown = new EventEmitter();\n        this.keyUp = new EventEmitter();\n        this.keyDown = new EventEmitter();\n        this.isPlayClick = false;\n        this.videoCells = [\n            {\n                beginTime: new Date().getTime() - 3 * 3600 * 1000,\n                endTime: new Date().getTime() - 1 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            },\n            {\n                beginTime: new Date().getTime() - 6 * 3600 * 1000,\n                endTime: new Date().getTime() - 4 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.verticalBarColor = 'rgba(0,0,0,1)';\n        this.bottomLineColor = 'rgba(0,0,0,1)';\n        this.borderColor = '#fff';\n        this.bgColor = '#fff';\n        this.playBarColor = '#448aff';\n    }\n    /**\n     * Browser change event\n     */\n    onResize() {\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        this.canvasW = this.canvas.parentNode.offsetWidth;\n        this.init(this.startTimestamp, this.timecell, false);\n    }\n    /**\n     * Keyboard press event\n     */\n    onKeyDown(event) {\n        if (Number(event.keyCode) === 37) {\n            this.playTime = Number(this.playTime) - this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) - this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        else if (Number(event.keyCode === 39)) {\n            this.playTime = Number(this.playTime) + this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) + this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.keyDown.emit(this.playTime);\n    }\n    /**\n     * Keyboard release event\n     */\n    onKeyUp(event) {\n        if (Number(event.keyCode) === 13 || Number(event.keyCode === 32)) {\n            this.isPlayClick ? this.onPauseClick() : this.onPlayClick();\n        }\n        this.keyUp.emit(this.playTime);\n    }\n    ngOnInit() {\n        // Initialize data video group event stamp to show new Date().getTime()- number of hours\n        // Assign the Canvas DOM to the variable Canvas\n        this.canvas = this.canvasExp.nativeElement;\n        // Define the area of the canvas\n        this.ctx = this.canvas.getContext('2d');\n        // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        // Store the width and height of the canvas\n        this.canvasW = this.canvas.width;\n        this.canvas.height = this.canvasHeight;\n        this.canvasH = this.canvas.height;\n        // Assign the video array to Timecell\n        this.timecell = this.videoCells;\n        // Initialize the number of steps per minute\n        this.minutesPerStep = [\n            1,\n            2,\n            5,\n            10,\n            15,\n            20,\n            30,\n            60,\n            120,\n            180,\n            240,\n            360,\n            720,\n            1440\n        ];\n        // Initialization style\n        // Minimum width between scales, in units of px 20px\n        this.graduationStep = 20;\n        // The timeline shows the time rounded up according to the time threshold\n        this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n            Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) :\n            24;\n        // The leftmost timestamp defaults to 12 hours before the current time\n        this.startTimestamp = Number(this.startTimeThreshold);\n        // Default distance 80\n        this.distanceBetweenGtitle = 80;\n        // Default zoom 24\n        this.zoom = 24;\n        // Default false\n        this.gIsMousedown = false;\n        this.gIsMousemove = false;\n        this.gMousedownCursor = undefined;\n        // px/ms\n        this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        // The initial X position of the playback icon is in the middle of the scale\n        this.playBarOffsetX = this.canvasW / 2;\n        this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n        this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n        this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n        this.playBarOffsetY1 = (this.scale * 2.5);\n        this.playBarOffsetY2 = ((this.scale * 3.5));\n        // Initialize the timeline\n        this.init(this.startTimestamp, this.timecell, false);\n        // Draw the play button\n        this.drawPalyBar();\n    }\n    ngOnChanges(changes) {\n        // Refactor the playback component when the width and height change\n        if (changes.canvasHeight) {\n            this.canvasHeight = changes.canvasHeight.currentValue;\n            // Assign the Canvas DOM to the variable Canvas\n            this.canvas = this.canvasExp.nativeElement;\n            // Define the area of the canvas\n            this.ctx = this.canvas.getContext('2d');\n            // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n            this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n            // Store the width and height of the canvas\n            this.canvasW = this.canvas.width;\n            this.canvas.height = this.canvasHeight;\n            this.canvasH = this.canvas.height;\n            // Assign the video array to Timecell\n            this.timecell = this.videoCells;\n            this.minutesPerStep = [\n                1,\n                2,\n                5,\n                10,\n                15,\n                20,\n                30,\n                60,\n                120,\n                180,\n                240,\n                360,\n                720,\n                1440\n            ];\n            // The timeline shows the time rounded up according to the time threshold\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n                Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            // The leftmost timestamp defaults to 12 hours before the current time\n            this.startTimestamp = Number(this.startTimeThreshold);\n            this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n            // The initial X position of the playback icon is in the middle of the scale\n            this.playBarOffsetX = this.canvasW / 2;\n            this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n            // Current timestamp\n            this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n            this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n            this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n            this.playBarOffsetY1 = (this.scale * 2.5);\n            this.playBarOffsetY2 = ((this.scale * 3.5));\n            this.init(this.startTimestamp, this.timecell, false);\n            this.drawPalyBar();\n        }\n        if (changes.videoCells) {\n            this.videoCells = changes.videoCells.currentValue;\n            this.timecell = this.videoCells;\n            this.add_cells(this.timecell);\n            // this.init(this.startTimestamp, this.timecell, true);\n            // this.drawPalyBar();\n        }\n        if (changes.startTimeThreshold) {\n            const value = changes.startTimeThreshold.currentValue;\n            if (changes.startTimeThreshold.currentValue instanceof String) {\n                this.startTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.startTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.startTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            this.startTimestamp = Number(this.startTimeThreshold);\n            // this.init(this.startTimestamp, this.timecell, false);\n        }\n        if (changes.endTimeThreshold) {\n            const value = changes.endTimeThreshold.currentValue;\n            if (changes.endTimeThreshold.currentValue instanceof String) {\n                this.endTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.endTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.endTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n        }\n        if (changes.playTime) {\n            const value = changes.playTime.currentValue;\n            if (changes.playTime.currentValue instanceof String) {\n                this.playTime = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.playTime = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.playTime = Number(value);\n            }\n            // use SetTimeOut Timer to make it  asynchronous\n            setTimeout(() => {\n                this.set_time_to_middle(new Date(this.playTime).getTime());\n            }, 100);\n        }\n        if (changes.speed) {\n            this.speed = Number(changes.speed.currentValue) * 1000;\n        }\n        if (changes.forWardValue) {\n            this.forWardValue = Number(changes.forWardValue.currentValue) * 1000;\n        }\n        if (changes.isPlayClick) {\n            if (changes.isPlayClick.currentValue) {\n                this.onPlayClick();\n            }\n            else {\n                this.onPauseClick();\n            }\n        }\n    }\n    /**\n     * Initialize\n     * @param  startTimestamp Leftmost time\n     * @param  timecell Video segment array\n     * @param  redrawFlag Whether to redraw the mark\n     */\n    init(startTimestamp, timecell, redrawFlag) {\n        this.timecell = timecell;\n        this.startTimestamp = startTimestamp;\n        if (this.currentTimestamp >=\n            this.endTimeThreshold) {\n            this.startTimestamp =\n                Number(this.endTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        else if (this.currentTimestamp <=\n            this.startTimeThreshold) {\n            this.startTimestamp =\n                Number(this.startTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        this.drawCellBg();\n        this.add_graduations(startTimestamp);\n        this.add_cells(timecell);\n        // Draw the verticalBar\n        this.drawLine(0, this.canvasH, this.canvasW, this.canvasH, this.bottomLineColor, 1);\n    }\n    /**\n     * Draw add scale\n     * @param  startTimestamp Leftmost time\n     */\n    add_graduations(startTimestamp) {\n        // px/min\n        const pxPerMin = this.canvasW / (this.hoursPerRuler * 60);\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000);\n        // The default minimum value of PX/steo is 20px\n        let pxPerStep = this.graduationStep;\n        // Min/steo\n        let minPerStep = pxPerStep / pxPerMin;\n        for (const v of this.minutesPerStep) {\n            if (minPerStep <= v) {\n                // Keep each cell within the range specified by minutesPerStep\n                minPerStep = v;\n                pxPerStep = pxPerMin * minPerStep;\n                break;\n            }\n        }\n        let mediumStep = 30;\n        for (const v of this.minutesPerStep) {\n            if (this.distanceBetweenGtitle / pxPerMin <= v) {\n                mediumStep = v;\n                break;\n            }\n        }\n        // The total number\n        const numSteps = this.canvasW / pxPerStep;\n        let graduationLeft;\n        let graduationTime;\n        let caretClass;\n        let lineH;\n        // The initial offset time (ms)\n        const msOffset = this.ms_to_next_step(startTimestamp, minPerStep * 60 * 1000);\n        // The initial offset is (px)\n        const pxOffset = msOffset * pxPerMs;\n        // ms/step\n        const msPerStep = pxPerStep / pxPerMs;\n        for (let i = 0; i < numSteps; i++) {\n            // Distance = offset distance to start + steps *px/ steps\n            graduationLeft = pxOffset + i * pxPerStep;\n            // Time = left start time + offset time + steps *ms/ steps\n            graduationTime =\n                Number(startTimestamp) +\n                    Number(msOffset) +\n                    i * Number(msPerStep);\n            const date = new Date(graduationTime);\n            if (date.getUTCHours() === 0 && date.getUTCMinutes() === 0) {\n                caretClass = 'big';\n                lineH = (this.scale * 1.25);\n                const bigDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(bigDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else if ((graduationTime / (60 * 1000)) % mediumStep === 0) {\n                caretClass = 'middle';\n                lineH = (this.scale * 0.75);\n                const middleDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(middleDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else {\n                lineH = (this.scale * 0.5);\n            }\n            // drawLine(graduationLeft,0,graduationLeft,lineH,\"rgba(151,158,167,0.4)\",1);\n            this.drawLine(graduationLeft, 0, graduationLeft, lineH, this.verticalBarColor, 1);\n        }\n    }\n    /**\n     * Draw the play button\n     */\n    drawPalyBar() {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.playBarOffsetX, 0);\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.strokeStyle = this.playBarColor;\n        this.ctx.stroke();\n        this.ctx.moveTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.fill();\n        this.ctx.closePath();\n        // this.init(this.startTimestamp, this.timecell, false);\n        const time = Number(this.currentTimestamp);\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), this.playBarOffsetX, (this.scale * 4.25));\n    }\n    /**\n     * Draw the line\n     * @param  beginX The X-axis to start with\n     * @param  beginY The Y-axis to start with\n     * @param  endX The end of the X-axis\n     * @param  endY The end of the Y-axis\n     * @param  color color\n     * @param  width width\n     */\n    drawLine(beginX, beginY, endX, endY, color, width) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(beginX, beginY);\n        this.ctx.lineTo(endX, endY);\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = width;\n        this.ctx.stroke();\n    }\n    /**\n     * Add video segment\n     * @param  cells Video array\n     */\n    add_cells(cells) {\n        cells.forEach((cell) => {\n            this.draw_cell(cell);\n        });\n    }\n    /**\n     * Draw video blocks\n     * @param  cell The cell includes beginTime Ms; The endTime ms; style;\n     */\n    draw_cell(cell) {\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000); // px/ms\n        const beginX = (cell.beginTime - this.startTimestamp) * pxPerMs;\n        const cellWidth = (cell.endTime - cell.beginTime) * pxPerMs;\n        this.ctx.fillStyle = cell.style.background;\n        this.ctx.fillRect(beginX, 0, cellWidth, (this.scale * 0.75));\n    }\n    /**\n     * Draws the background of the video block\n     */\n    drawCellBg() {\n        this.ctx.fillStyle = 'rgba(69, 72, 76, 0.5)';\n        this.ctx.fillRect(0, 0, this.canvasW, 0);\n    }\n    /**\n     * Drag/click the Mousedown event\n     */\n    mousedownFunc(e) {\n        this.gIsMousedown = true;\n        this.gMousedownCursor = this.get_cursor_x_position(e).posX;\n        this.gMousedownCursorY = this.get_cursor_x_position(e).posY;\n    }\n    /**\n     * Drag/mouse hover to display mousemove events\n     */\n    mousemoveFunc(e) {\n        this.clearCanvas();\n        const posX = this.get_cursor_x_position(e).posX;\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        const diffX = posX - this.gMousedownCursor;\n        if (this.gIsMousedown) {\n            if (this.gMousedownCursor >= this.playBarOffsetX1 &&\n                this.gMousedownCursor <= this.playBarOffsetX2 &&\n                this.gMousedownCursorY >= this.playBarOffsetY1 &&\n                this.gMousedownCursorY <= this.playBarOffsetY2) {\n                // this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n                // this.playBarOffsetX = posX;\n                // this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n                // this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n                this.startTimestamp =\n                    this.startTimestamp + Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    (this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs));\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, false);\n                this.gIsMousemove = true;\n            }\n            else {\n                this.startTimestamp =\n                    this.startTimestamp - Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs);\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, true);\n                this.gIsMousemove = true;\n                this.gMousedownCursor = posX;\n            }\n            this.mouseUp.emit(this.currentTimestamp);\n        }\n        else {\n            const time = this.startTimestamp + posX / pxPerMs;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n            this.drawLine(posX, 0, posX, 50, 'rgb(194, 202, 215)', 1);\n            this.ctx.fillStyle = 'rgb(194, 202, 215)';\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), posX, (this.scale * 3));\n        }\n    }\n    /**\n     * Drag/click the Mouseup event\n     */\n    mouseupFunc(e) {\n        if (this.gIsMousemove) {\n            // Drag events\n            this.gIsMousemove = false;\n            this.gIsMousedown = false;\n            this.playTime =\n                this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        }\n        else {\n            // Click event\n            this.gIsMousedown = false;\n            // Mouse distance (px)\n            const posx = this.get_cursor_x_position(e).posX;\n            // ms/px\n            const msPerPx = (this.zoom * 3600 * 1000) / this.canvasW;\n            this.playTime = this.startTimestamp + posx * msPerPx;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.mouseDown.emit(this.playTime);\n    }\n    /**\n     * Mouseout of the hidden time mouseout event\n     */\n    mouseoutFunc() {\n        this.clearCanvas();\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        this.currentTimestamp =\n            this.startTimestamp +\n                Math.round(this.playBarOffsetX / pxPerMs);\n        this.drawPalyBar();\n        this.init(this.startTimestamp, this.timecell, true);\n    }\n    /**\n     * Scroll to the center of the timeline for the mousewheel event\n     */\n    mousewheelFunc(event) {\n        if (event && event.preventDefault) {\n            event.preventDefault();\n        }\n        else {\n            window.event.returnValue = false;\n            return false;\n        }\n        const e = window.event || event;\n        const delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));\n        // Ms Remember the current middle time\n        const middleTime = this.startTimestamp + (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n        if (delta < 0) {\n            this.zoom = this.zoom + 4;\n            if (this.zoom >= 24) {\n                // Shrink to a minimum of 24 hours\n                this.zoom = 24;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        else if (delta > 0) {\n            // amplification\n            this.zoom = this.zoom - 4;\n            if (this.zoom <= 1) {\n                // Zoom in at most one hour\n                this.zoom = 1;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        this.clearCanvas();\n        // // startTimestamp = current middle time - zoom /2\n        this.startTimestamp =\n            middleTime - (this.hoursPerRuler * 3600 * 1000) / 2;\n        this.init(this.startTimestamp, this.timecell, true);\n        this.drawPalyBar();\n    }\n    /**\n     * Get the mouse POSx\n     * @param  e event\n     */\n    get_cursor_x_position(e) {\n        let posx = 0;\n        let posy = 0;\n        if (!e) {\n            e = window.event;\n        }\n        if (e.offsetX || e.offsetY) {\n            posx = e.offsetX;\n            posy = e.offsetY;\n        }\n        return { posX: posx, posY: posy };\n    }\n    /**\n     * The offset of the left start time, returns the unit ms\n     * @param  timestamp The time stamp\n     * @param  step The offset\n     */\n    ms_to_next_step(timestamp, step) {\n        const remainder = timestamp % step;\n        return remainder ? step - remainder : 0;\n    }\n    /**\n     * Set the time to jump to the middle red line\n     *  @param  time Unit of ms\n     */\n    set_time_to_middle(time) {\n        if (this.ctx) {\n            this.clearCanvas();\n            this.startTimestamp = time - (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n            this.currentTimestamp = time;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n        }\n    }\n    /**\n     * 清除canvas 每次重新绘制需要先清除\n     */\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.canvasW, (this.scale * 7.5));\n    }\n    /**\n     * Click to play\n     */\n    onPlayClick() {\n        // this.setTimeMove = undefined;\n        this.isPlayClick = true;\n        this.setTimeMove = interval(this.speed).subscribe((d) => {\n            this.playTime = Number(this.playTime) + 1 * 1000;\n            this.playClick.emit(this.playTime);\n            this.set_time_to_middle(this.playTime);\n        });\n    }\n    /**\n     * Click on the pause\n     */\n    onPauseClick() {\n        this.isPlayClick = false;\n        if (this.setTimeMove) {\n            // this.setTimeMove = undefined;\n            this.setTimeMove.unsubscribe();\n            this.playClick.emit(this.playTime);\n        }\n    }\n    /**\n     * Change video segment\n     */\n    changeVideo() {\n        const cells = [\n            {\n                beginTime: new Date().getTime() - 1 * 1000 * 3600,\n                endTime: new Date().getTime() + 2 * 1000 * 3600,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.clearCanvas();\n        this.drawPalyBar();\n        this.init(this.startTimestamp, cells, true);\n    }\n    /**\n     * Temporary unused\n     * @param event MatDatepickerInputEvent(Date)\n     */\n    selectedTime(event) {\n        const timestamp = new Date(event.value.getTime());\n        this.set_time_to_middle(Number(timestamp));\n    }\n    /**\n     * Temporary unused\n     * @param event MouseEvent\n     */\n    onDragStart(e) {\n        e.preventDefault();\n        return false;\n    }\n}\nNgxVideoTimelineComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nNgxVideoTimelineComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.2.8\", type: NgxVideoTimelineComponent, selector: \"ngx-video-timeline\", inputs: { canvasHeight: \"canvasHeight\", playTime: \"playTime\", speed: \"speed\", forWardValue: \"forWardValue\", startTimeThreshold: \"startTimeThreshold\", endTimeThreshold: \"endTimeThreshold\", borderColor: \"borderColor\", bgColor: \"bgColor\", bottomLineColor: \"bottomLineColor\", verticalBarColor: \"verticalBarColor\", playBarColor: \"playBarColor\", videoCells: \"videoCells\", isPlayClick: \"isPlayClick\" }, outputs: { playClick: \"playClick\", mouseUp: \"mouseUp\", mouseDown: \"mouseDown\", keyUp: \"keyUp\", keyDown: \"keyDown\" }, host: { listeners: { \"window:resize\": \"onResize()\", \"window:keydown\": \"onKeyDown($event)\", \"window:keyup\": \"onKeyUp($event)\" } }, viewQueries: [{ propertyName: \"canvasExp\", first: true, predicate: [\"timeline\"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"], dependencies: [{ kind: \"directive\", type: i1.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-video-timeline', template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"] }]\n        }], ctorParameters: function () { return []; }, propDecorators: { canvasHeight: [{\n                type: Input\n            }], playTime: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], forWardValue: [{\n                type: Input\n            }], startTimeThreshold: [{\n                type: Input\n            }], endTimeThreshold: [{\n                type: Input\n            }], borderColor: [{\n                type: Input\n            }], bgColor: [{\n                type: Input\n            }], bottomLineColor: [{\n                type: Input\n            }], verticalBarColor: [{\n                type: Input\n            }], playBarColor: [{\n                type: Input\n            }], videoCells: [{\n                type: Input\n            }], isPlayClick: [{\n                type: Input\n            }], playClick: [{\n                type: Output\n            }], mouseUp: [{\n                type: Output\n            }], mouseDown: [{\n                type: Output\n            }], keyUp: [{\n                type: Output\n            }], keyDown: [{\n                type: Output\n            }], canvasExp: [{\n                type: ViewChild,\n                args: ['timeline', { static: true }]\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }], onKeyDown: [{\n                type: HostListener,\n                args: ['window:keydown', ['$event']]\n            }], onKeyUp: [{\n                type: HostListener,\n                args: ['window:keyup', ['$event']]\n            }] } });","originalLength":112052,"removedExports":[],"renderedExports":["DateUtil","NgxVideoTimelineComponent"],"renderedLength":32301},"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/lib/timeline.module.mjs":{"code":"class NgxVideoTimelineModule {\n}\nNgxVideoTimelineModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxVideoTimelineModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, declarations: [NgxVideoTimelineComponent], imports: [CommonModule], exports: [NgxVideoTimelineComponent] });\nNgxVideoTimelineModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, imports: [CommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [NgxVideoTimelineComponent],\n                    imports: [\n                        CommonModule\n                    ],\n                    exports: [NgxVideoTimelineComponent]\n                }]\n        }] });","originalLength":2529,"removedExports":[],"renderedExports":["NgxVideoTimelineModule"],"renderedLength":1062},"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/public-api.mjs":{"code":"/*\n * Public API Surface of timeline\n */","originalLength":628,"removedExports":[],"renderedExports":[],"renderedLength":40},"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/ngx-video-timeline.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":512,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, Output, ViewChild, HostListener, NgModule } from '@angular/core';\nimport { interval } from 'rxjs';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * A utility class for working with dates.\n */\nclass DateUtil {\n    /**\n     * Formats the given date according to the specified format.\n     * @param date The date to format.\n     * @param format The format string, using the following placeholders:\n     *   - YYYY: four-digit year\n     *   - MM: two-digit month (zero-padded)\n     *   - DD: two-digit day of month (zero-padded)\n     *   - HH: two-digit hour (zero-padded, 24-hour format)\n     *   - mm: two-digit minute (zero-padded)\n     *   - ss: two-digit second (zero-padded)\n     * @returns The formatted date string.\n     */\n    static formatDate(date, format) {\n        // Extract the year, month, day, hours, minutes, and seconds from the date\n        const year = date.getFullYear().toString();\n        const month = (date.getMonth() + 1).toString().padStart(2, '0');\n        const day = date.getDate().toString().padStart(2, '0');\n        const hours = date.getHours().toString().padStart(2, '0');\n        const minutes = date.getMinutes().toString().padStart(2, '0');\n        const seconds = date.getSeconds().toString().padStart(2, '0');\n        // Replace the placeholders in the format string with the corresponding date parts\n        return format\n            .replace('YYYY', year)\n            .replace('MM', month)\n            .replace('DD', day)\n            .replace('HH', hours)\n            .replace('mm', minutes)\n            .replace('ss', seconds);\n    }\n}\nclass NgxVideoTimelineComponent {\n    constructor() {\n        // The height of the outer canvas\n        this.canvasHeight = 50;\n        // Canvas scale is adjusted according to outer height\n        this.scale = this.canvasHeight / 4.55;\n        // The position of the X-axis when the mouse is pressed\n        this.gMousedownCursor = undefined;\n        // The position of the y-axis when the mouse is pressed\n        this.gMousedownCursorY = undefined;\n        // this.startTimeThreshold = new Date().getTime() - 1 * 0.5 * 3600 * 1000;\n        // this.endTimeThreshold = new Date().getTime() + 1 * 1 * 3600 * 1000;\n        this.forWardValue = 5000;\n        this.speed = 1000;\n        this.playTime = new Date().getTime();\n        this.startTimeThreshold = new Date().getTime() - 1 * 12 * 3600 * 1000;\n        this.endTimeThreshold = new Date().getTime() + 1 * 12 * 3600 * 1000;\n        this.playClick = new EventEmitter();\n        this.mouseUp = new EventEmitter();\n        this.mouseDown = new EventEmitter();\n        this.keyUp = new EventEmitter();\n        this.keyDown = new EventEmitter();\n        this.isPlayClick = false;\n        this.videoCells = [\n            {\n                beginTime: new Date().getTime() - 3 * 3600 * 1000,\n                endTime: new Date().getTime() - 1 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            },\n            {\n                beginTime: new Date().getTime() - 6 * 3600 * 1000,\n                endTime: new Date().getTime() - 4 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.verticalBarColor = 'rgba(0,0,0,1)';\n        this.bottomLineColor = 'rgba(0,0,0,1)';\n        this.borderColor = '#fff';\n        this.bgColor = '#fff';\n        this.playBarColor = '#448aff';\n    }\n    /**\n     * Browser change event\n     */\n    onResize() {\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        this.canvasW = this.canvas.parentNode.offsetWidth;\n        this.init(this.startTimestamp, this.timecell, false);\n    }\n    /**\n     * Keyboard press event\n     */\n    onKeyDown(event) {\n        if (Number(event.keyCode) === 37) {\n            this.playTime = Number(this.playTime) - this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) - this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        else if (Number(event.keyCode === 39)) {\n            this.playTime = Number(this.playTime) + this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) + this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.keyDown.emit(this.playTime);\n    }\n    /**\n     * Keyboard release event\n     */\n    onKeyUp(event) {\n        if (Number(event.keyCode) === 13 || Number(event.keyCode === 32)) {\n            this.isPlayClick ? this.onPauseClick() : this.onPlayClick();\n        }\n        this.keyUp.emit(this.playTime);\n    }\n    ngOnInit() {\n        // Initialize data video group event stamp to show new Date().getTime()- number of hours\n        // Assign the Canvas DOM to the variable Canvas\n        this.canvas = this.canvasExp.nativeElement;\n        // Define the area of the canvas\n        this.ctx = this.canvas.getContext('2d');\n        // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        // Store the width and height of the canvas\n        this.canvasW = this.canvas.width;\n        this.canvas.height = this.canvasHeight;\n        this.canvasH = this.canvas.height;\n        // Assign the video array to Timecell\n        this.timecell = this.videoCells;\n        // Initialize the number of steps per minute\n        this.minutesPerStep = [\n            1,\n            2,\n            5,\n            10,\n            15,\n            20,\n            30,\n            60,\n            120,\n            180,\n            240,\n            360,\n            720,\n            1440\n        ];\n        // Initialization style\n        // Minimum width between scales, in units of px 20px\n        this.graduationStep = 20;\n        // The timeline shows the time rounded up according to the time threshold\n        this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n            Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) :\n            24;\n        // The leftmost timestamp defaults to 12 hours before the current time\n        this.startTimestamp = Number(this.startTimeThreshold);\n        // Default distance 80\n        this.distanceBetweenGtitle = 80;\n        // Default zoom 24\n        this.zoom = 24;\n        // Default false\n        this.gIsMousedown = false;\n        this.gIsMousemove = false;\n        this.gMousedownCursor = undefined;\n        // px/ms\n        this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        // The initial X position of the playback icon is in the middle of the scale\n        this.playBarOffsetX = this.canvasW / 2;\n        this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n        this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n        this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n        this.playBarOffsetY1 = (this.scale * 2.5);\n        this.playBarOffsetY2 = ((this.scale * 3.5));\n        // Initialize the timeline\n        this.init(this.startTimestamp, this.timecell, false);\n        // Draw the play button\n        this.drawPalyBar();\n    }\n    ngOnChanges(changes) {\n        // Refactor the playback component when the width and height change\n        if (changes.canvasHeight) {\n            this.canvasHeight = changes.canvasHeight.currentValue;\n            // Assign the Canvas DOM to the variable Canvas\n            this.canvas = this.canvasExp.nativeElement;\n            // Define the area of the canvas\n            this.ctx = this.canvas.getContext('2d');\n            // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n            this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n            // Store the width and height of the canvas\n            this.canvasW = this.canvas.width;\n            this.canvas.height = this.canvasHeight;\n            this.canvasH = this.canvas.height;\n            // Assign the video array to Timecell\n            this.timecell = this.videoCells;\n            this.minutesPerStep = [\n                1,\n                2,\n                5,\n                10,\n                15,\n                20,\n                30,\n                60,\n                120,\n                180,\n                240,\n                360,\n                720,\n                1440\n            ];\n            // The timeline shows the time rounded up according to the time threshold\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n                Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            // The leftmost timestamp defaults to 12 hours before the current time\n            this.startTimestamp = Number(this.startTimeThreshold);\n            this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n            // The initial X position of the playback icon is in the middle of the scale\n            this.playBarOffsetX = this.canvasW / 2;\n            this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n            // Current timestamp\n            this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n            this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n            this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n            this.playBarOffsetY1 = (this.scale * 2.5);\n            this.playBarOffsetY2 = ((this.scale * 3.5));\n            this.init(this.startTimestamp, this.timecell, false);\n            this.drawPalyBar();\n        }\n        if (changes.videoCells) {\n            this.videoCells = changes.videoCells.currentValue;\n            this.timecell = this.videoCells;\n            this.add_cells(this.timecell);\n            // this.init(this.startTimestamp, this.timecell, true);\n            // this.drawPalyBar();\n        }\n        if (changes.startTimeThreshold) {\n            const value = changes.startTimeThreshold.currentValue;\n            if (changes.startTimeThreshold.currentValue instanceof String) {\n                this.startTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.startTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.startTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            this.startTimestamp = Number(this.startTimeThreshold);\n            // this.init(this.startTimestamp, this.timecell, false);\n        }\n        if (changes.endTimeThreshold) {\n            const value = changes.endTimeThreshold.currentValue;\n            if (changes.endTimeThreshold.currentValue instanceof String) {\n                this.endTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.endTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.endTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n        }\n        if (changes.playTime) {\n            const value = changes.playTime.currentValue;\n            if (changes.playTime.currentValue instanceof String) {\n                this.playTime = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.playTime = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.playTime = Number(value);\n            }\n            // use SetTimeOut Timer to make it  asynchronous\n            setTimeout(() => {\n                this.set_time_to_middle(new Date(this.playTime).getTime());\n            }, 100);\n        }\n        if (changes.speed) {\n            this.speed = Number(changes.speed.currentValue) * 1000;\n        }\n        if (changes.forWardValue) {\n            this.forWardValue = Number(changes.forWardValue.currentValue) * 1000;\n        }\n        if (changes.isPlayClick) {\n            if (changes.isPlayClick.currentValue) {\n                this.onPlayClick();\n            }\n            else {\n                this.onPauseClick();\n            }\n        }\n    }\n    /**\n     * Initialize\n     * @param  startTimestamp Leftmost time\n     * @param  timecell Video segment array\n     * @param  redrawFlag Whether to redraw the mark\n     */\n    init(startTimestamp, timecell, redrawFlag) {\n        this.timecell = timecell;\n        this.startTimestamp = startTimestamp;\n        if (this.currentTimestamp >=\n            this.endTimeThreshold) {\n            this.startTimestamp =\n                Number(this.endTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        else if (this.currentTimestamp <=\n            this.startTimeThreshold) {\n            this.startTimestamp =\n                Number(this.startTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        this.drawCellBg();\n        this.add_graduations(startTimestamp);\n        this.add_cells(timecell);\n        // Draw the verticalBar\n        this.drawLine(0, this.canvasH, this.canvasW, this.canvasH, this.bottomLineColor, 1);\n    }\n    /**\n     * Draw add scale\n     * @param  startTimestamp Leftmost time\n     */\n    add_graduations(startTimestamp) {\n        // px/min\n        const pxPerMin = this.canvasW / (this.hoursPerRuler * 60);\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000);\n        // The default minimum value of PX/steo is 20px\n        let pxPerStep = this.graduationStep;\n        // Min/steo\n        let minPerStep = pxPerStep / pxPerMin;\n        for (const v of this.minutesPerStep) {\n            if (minPerStep <= v) {\n                // Keep each cell within the range specified by minutesPerStep\n                minPerStep = v;\n                pxPerStep = pxPerMin * minPerStep;\n                break;\n            }\n        }\n        let mediumStep = 30;\n        for (const v of this.minutesPerStep) {\n            if (this.distanceBetweenGtitle / pxPerMin <= v) {\n                mediumStep = v;\n                break;\n            }\n        }\n        // The total number\n        const numSteps = this.canvasW / pxPerStep;\n        let graduationLeft;\n        let graduationTime;\n        let caretClass;\n        let lineH;\n        // The initial offset time (ms)\n        const msOffset = this.ms_to_next_step(startTimestamp, minPerStep * 60 * 1000);\n        // The initial offset is (px)\n        const pxOffset = msOffset * pxPerMs;\n        // ms/step\n        const msPerStep = pxPerStep / pxPerMs;\n        for (let i = 0; i < numSteps; i++) {\n            // Distance = offset distance to start + steps *px/ steps\n            graduationLeft = pxOffset + i * pxPerStep;\n            // Time = left start time + offset time + steps *ms/ steps\n            graduationTime =\n                Number(startTimestamp) +\n                    Number(msOffset) +\n                    i * Number(msPerStep);\n            const date = new Date(graduationTime);\n            if (date.getUTCHours() === 0 && date.getUTCMinutes() === 0) {\n                caretClass = 'big';\n                lineH = (this.scale * 1.25);\n                const bigDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(bigDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else if ((graduationTime / (60 * 1000)) % mediumStep === 0) {\n                caretClass = 'middle';\n                lineH = (this.scale * 0.75);\n                const middleDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(middleDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else {\n                lineH = (this.scale * 0.5);\n            }\n            // drawLine(graduationLeft,0,graduationLeft,lineH,\"rgba(151,158,167,0.4)\",1);\n            this.drawLine(graduationLeft, 0, graduationLeft, lineH, this.verticalBarColor, 1);\n        }\n    }\n    /**\n     * Draw the play button\n     */\n    drawPalyBar() {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.playBarOffsetX, 0);\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.strokeStyle = this.playBarColor;\n        this.ctx.stroke();\n        this.ctx.moveTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.fill();\n        this.ctx.closePath();\n        // this.init(this.startTimestamp, this.timecell, false);\n        const time = Number(this.currentTimestamp);\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), this.playBarOffsetX, (this.scale * 4.25));\n    }\n    /**\n     * Draw the line\n     * @param  beginX The X-axis to start with\n     * @param  beginY The Y-axis to start with\n     * @param  endX The end of the X-axis\n     * @param  endY The end of the Y-axis\n     * @param  color color\n     * @param  width width\n     */\n    drawLine(beginX, beginY, endX, endY, color, width) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(beginX, beginY);\n        this.ctx.lineTo(endX, endY);\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = width;\n        this.ctx.stroke();\n    }\n    /**\n     * Add video segment\n     * @param  cells Video array\n     */\n    add_cells(cells) {\n        cells.forEach((cell) => {\n            this.draw_cell(cell);\n        });\n    }\n    /**\n     * Draw video blocks\n     * @param  cell The cell includes beginTime Ms; The endTime ms; style;\n     */\n    draw_cell(cell) {\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000); // px/ms\n        const beginX = (cell.beginTime - this.startTimestamp) * pxPerMs;\n        const cellWidth = (cell.endTime - cell.beginTime) * pxPerMs;\n        this.ctx.fillStyle = cell.style.background;\n        this.ctx.fillRect(beginX, 0, cellWidth, (this.scale * 0.75));\n    }\n    /**\n     * Draws the background of the video block\n     */\n    drawCellBg() {\n        this.ctx.fillStyle = 'rgba(69, 72, 76, 0.5)';\n        this.ctx.fillRect(0, 0, this.canvasW, 0);\n    }\n    /**\n     * Drag/click the Mousedown event\n     */\n    mousedownFunc(e) {\n        this.gIsMousedown = true;\n        this.gMousedownCursor = this.get_cursor_x_position(e).posX;\n        this.gMousedownCursorY = this.get_cursor_x_position(e).posY;\n    }\n    /**\n     * Drag/mouse hover to display mousemove events\n     */\n    mousemoveFunc(e) {\n        this.clearCanvas();\n        const posX = this.get_cursor_x_position(e).posX;\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        const diffX = posX - this.gMousedownCursor;\n        if (this.gIsMousedown) {\n            if (this.gMousedownCursor >= this.playBarOffsetX1 &&\n                this.gMousedownCursor <= this.playBarOffsetX2 &&\n                this.gMousedownCursorY >= this.playBarOffsetY1 &&\n                this.gMousedownCursorY <= this.playBarOffsetY2) {\n                // this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n                // this.playBarOffsetX = posX;\n                // this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n                // this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n                this.startTimestamp =\n                    this.startTimestamp + Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    (this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs));\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, false);\n                this.gIsMousemove = true;\n            }\n            else {\n                this.startTimestamp =\n                    this.startTimestamp - Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs);\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, true);\n                this.gIsMousemove = true;\n                this.gMousedownCursor = posX;\n            }\n            this.mouseUp.emit(this.currentTimestamp);\n        }\n        else {\n            const time = this.startTimestamp + posX / pxPerMs;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n            this.drawLine(posX, 0, posX, 50, 'rgb(194, 202, 215)', 1);\n            this.ctx.fillStyle = 'rgb(194, 202, 215)';\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), posX, (this.scale * 3));\n        }\n    }\n    /**\n     * Drag/click the Mouseup event\n     */\n    mouseupFunc(e) {\n        if (this.gIsMousemove) {\n            // Drag events\n            this.gIsMousemove = false;\n            this.gIsMousedown = false;\n            this.playTime =\n                this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        }\n        else {\n            // Click event\n            this.gIsMousedown = false;\n            // Mouse distance (px)\n            const posx = this.get_cursor_x_position(e).posX;\n            // ms/px\n            const msPerPx = (this.zoom * 3600 * 1000) / this.canvasW;\n            this.playTime = this.startTimestamp + posx * msPerPx;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.mouseDown.emit(this.playTime);\n    }\n    /**\n     * Mouseout of the hidden time mouseout event\n     */\n    mouseoutFunc() {\n        this.clearCanvas();\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        this.currentTimestamp =\n            this.startTimestamp +\n                Math.round(this.playBarOffsetX / pxPerMs);\n        this.drawPalyBar();\n        this.init(this.startTimestamp, this.timecell, true);\n    }\n    /**\n     * Scroll to the center of the timeline for the mousewheel event\n     */\n    mousewheelFunc(event) {\n        if (event && event.preventDefault) {\n            event.preventDefault();\n        }\n        else {\n            window.event.returnValue = false;\n            return false;\n        }\n        const e = window.event || event;\n        const delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));\n        // Ms Remember the current middle time\n        const middleTime = this.startTimestamp + (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n        if (delta < 0) {\n            this.zoom = this.zoom + 4;\n            if (this.zoom >= 24) {\n                // Shrink to a minimum of 24 hours\n                this.zoom = 24;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        else if (delta > 0) {\n            // amplification\n            this.zoom = this.zoom - 4;\n            if (this.zoom <= 1) {\n                // Zoom in at most one hour\n                this.zoom = 1;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        this.clearCanvas();\n        // // startTimestamp = current middle time - zoom /2\n        this.startTimestamp =\n            middleTime - (this.hoursPerRuler * 3600 * 1000) / 2;\n        this.init(this.startTimestamp, this.timecell, true);\n        this.drawPalyBar();\n    }\n    /**\n     * Get the mouse POSx\n     * @param  e event\n     */\n    get_cursor_x_position(e) {\n        let posx = 0;\n        let posy = 0;\n        if (!e) {\n            e = window.event;\n        }\n        if (e.offsetX || e.offsetY) {\n            posx = e.offsetX;\n            posy = e.offsetY;\n        }\n        return { posX: posx, posY: posy };\n    }\n    /**\n     * The offset of the left start time, returns the unit ms\n     * @param  timestamp The time stamp\n     * @param  step The offset\n     */\n    ms_to_next_step(timestamp, step) {\n        const remainder = timestamp % step;\n        return remainder ? step - remainder : 0;\n    }\n    /**\n     * Set the time to jump to the middle red line\n     *  @param  time Unit of ms\n     */\n    set_time_to_middle(time) {\n        if (this.ctx) {\n            this.clearCanvas();\n            this.startTimestamp = time - (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n            this.currentTimestamp = time;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n        }\n    }\n    /**\n     * 清除canvas 每次重新绘制需要先清除\n     */\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.canvasW, (this.scale * 7.5));\n    }\n    /**\n     * Click to play\n     */\n    onPlayClick() {\n        // this.setTimeMove = undefined;\n        this.isPlayClick = true;\n        this.setTimeMove = interval(this.speed).subscribe((d) => {\n            this.playTime = Number(this.playTime) + 1 * 1000;\n            this.playClick.emit(this.playTime);\n            this.set_time_to_middle(this.playTime);\n        });\n    }\n    /**\n     * Click on the pause\n     */\n    onPauseClick() {\n        this.isPlayClick = false;\n        if (this.setTimeMove) {\n            // this.setTimeMove = undefined;\n            this.setTimeMove.unsubscribe();\n            this.playClick.emit(this.playTime);\n        }\n    }\n    /**\n     * Change video segment\n     */\n    changeVideo() {\n        const cells = [\n            {\n                beginTime: new Date().getTime() - 1 * 1000 * 3600,\n                endTime: new Date().getTime() + 2 * 1000 * 3600,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.clearCanvas();\n        this.drawPalyBar();\n        this.init(this.startTimestamp, cells, true);\n    }\n    /**\n     * Temporary unused\n     * @param event MatDatepickerInputEvent(Date)\n     */\n    selectedTime(event) {\n        const timestamp = new Date(event.value.getTime());\n        this.set_time_to_middle(Number(timestamp));\n    }\n    /**\n     * Temporary unused\n     * @param event MouseEvent\n     */\n    onDragStart(e) {\n        e.preventDefault();\n        return false;\n    }\n}\nNgxVideoTimelineComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nNgxVideoTimelineComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.2.8\", type: NgxVideoTimelineComponent, selector: \"ngx-video-timeline\", inputs: { canvasHeight: \"canvasHeight\", playTime: \"playTime\", speed: \"speed\", forWardValue: \"forWardValue\", startTimeThreshold: \"startTimeThreshold\", endTimeThreshold: \"endTimeThreshold\", borderColor: \"borderColor\", bgColor: \"bgColor\", bottomLineColor: \"bottomLineColor\", verticalBarColor: \"verticalBarColor\", playBarColor: \"playBarColor\", videoCells: \"videoCells\", isPlayClick: \"isPlayClick\" }, outputs: { playClick: \"playClick\", mouseUp: \"mouseUp\", mouseDown: \"mouseDown\", keyUp: \"keyUp\", keyDown: \"keyDown\" }, host: { listeners: { \"window:resize\": \"onResize()\", \"window:keydown\": \"onKeyDown($event)\", \"window:keyup\": \"onKeyUp($event)\" } }, viewQueries: [{ propertyName: \"canvasExp\", first: true, predicate: [\"timeline\"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"], dependencies: [{ kind: \"directive\", type: i1.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-video-timeline', template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"] }]\n        }], ctorParameters: function () { return []; }, propDecorators: { canvasHeight: [{\n                type: Input\n            }], playTime: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], forWardValue: [{\n                type: Input\n            }], startTimeThreshold: [{\n                type: Input\n            }], endTimeThreshold: [{\n                type: Input\n            }], borderColor: [{\n                type: Input\n            }], bgColor: [{\n                type: Input\n            }], bottomLineColor: [{\n                type: Input\n            }], verticalBarColor: [{\n                type: Input\n            }], playBarColor: [{\n                type: Input\n            }], videoCells: [{\n                type: Input\n            }], isPlayClick: [{\n                type: Input\n            }], playClick: [{\n                type: Output\n            }], mouseUp: [{\n                type: Output\n            }], mouseDown: [{\n                type: Output\n            }], keyUp: [{\n                type: Output\n            }], keyDown: [{\n                type: Output\n            }], canvasExp: [{\n                type: ViewChild,\n                args: ['timeline', { static: true }]\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }], onKeyDown: [{\n                type: HostListener,\n                args: ['window:keydown', ['$event']]\n            }], onKeyUp: [{\n                type: HostListener,\n                args: ['window:keyup', ['$event']]\n            }] } });\n\nclass NgxVideoTimelineModule {\n}\nNgxVideoTimelineModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxVideoTimelineModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, declarations: [NgxVideoTimelineComponent], imports: [CommonModule], exports: [NgxVideoTimelineComponent] });\nNgxVideoTimelineModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, imports: [CommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [NgxVideoTimelineComponent],\n                    imports: [\n                        CommonModule\n                    ],\n                    exports: [NgxVideoTimelineComponent]\n                }]\n        }] });\n\n/*\n * Public API Surface of timeline\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DateUtil, NgxVideoTimelineComponent, NgxVideoTimelineModule };\n//# sourceMappingURL=ngx-video-timeline.mjs.map\n","map":null},{"fileName":"ngx-video-timeline.mjs.map","needsCodeReference":false,"source":"{\"version\":3,\"file\":\"ngx-video-timeline.mjs\",\"sources\":[\"../../../projects/timeline/src/lib/timeline.component.ts\",\"../../../projects/timeline/src/lib/timeline.component.html\",\"../../../projects/timeline/src/lib/timeline.module.ts\",\"../../../projects/timeline/src/public-api.ts\",\"../../../projects/timeline/src/ngx-video-timeline.ts\"],\"sourcesContent\":[\"import {\\n    Component,\\n    ElementRef,\\n    EventEmitter,\\n    HostListener,\\n    Input,\\n    OnChanges,\\n    OnInit,\\n    Output, SimpleChanges,\\n    ViewChild\\n} from '@angular/core';\\nimport { interval, Subscription } from 'rxjs';\\n\\n/**\\n * A utility class for working with dates.\\n */\\nexport class DateUtil {\\n\\n  /**\\n   * Formats the given date according to the specified format.\\n   * @param date The date to format.\\n   * @param format The format string, using the following placeholders:\\n   *   - YYYY: four-digit year\\n   *   - MM: two-digit month (zero-padded)\\n   *   - DD: two-digit day of month (zero-padded)\\n   *   - HH: two-digit hour (zero-padded, 24-hour format)\\n   *   - mm: two-digit minute (zero-padded)\\n   *   - ss: two-digit second (zero-padded)\\n   * @returns The formatted date string.\\n   */\\n  static formatDate(date: Date, format: string): string {\\n    // Extract the year, month, day, hours, minutes, and seconds from the date\\n    const year = date.getFullYear().toString();\\n    const month = (date.getMonth() + 1).toString().padStart(2, '0');\\n    const day = date.getDate().toString().padStart(2, '0');\\n    const hours = date.getHours().toString().padStart(2, '0');\\n    const minutes = date.getMinutes().toString().padStart(2, '0');\\n    const seconds = date.getSeconds().toString().padStart(2, '0');\\n\\n    // Replace the placeholders in the format string with the corresponding date parts\\n    return format\\n      .replace('YYYY', year)\\n      .replace('MM', month)\\n      .replace('DD', day)\\n      .replace('HH', hours)\\n      .replace('mm', minutes)\\n      .replace('ss', seconds);\\n  }\\n}\\nexport interface CanvasPos {\\n    posX: number;\\n    posY: number;\\n}\\n\\nexport interface VideoCellStyleType {\\n    background: string;\\n}\\n\\nexport interface VideoCellType {\\n    beginTime: number | string;\\n    endTime: number | string;\\n    style?: VideoCellStyleType;\\n}\\n\\n\\n@Component({\\n    selector: 'ngx-video-timeline',\\n    templateUrl: './timeline.component.html',\\n    styleUrls: ['./timeline.component.scss']\\n})\\nexport class NgxVideoTimelineComponent implements OnInit, OnChanges {\\n\\n\\n    // The height of the outer canvas\\n    @Input() canvasHeight = 50;\\n\\n    // Canvas scale is adjusted according to outer height\\n    scale = this.canvasHeight / 4.55;\\n\\n    // Video playback time\\n    @Input() playTime: number | string | Date;\\n\\n    // The video plays at twice the speed\\n    @Input() speed: number;\\n\\n    // Video fast forward value\\n    @Input() forWardValue: number;\\n\\n    // Start time limit: Timestamp\\n    @Input() startTimeThreshold: number | string | Date;\\n\\n    // End time limit: Timestamp\\n    @Input() endTimeThreshold: number | string | Date;\\n\\n    // relation to Css Start\\n\\n    // color of canvas border\\n    @Input() borderColor: string;\\n\\n    // color of canvas backgraound\\n    @Input() bgColor: string;\\n\\n    // color of the bottomLine\\n    @Input() bottomLineColor: string;\\n\\n    // color of the verticalBar\\n    @Input() verticalBarColor: string;\\n\\n    // color of the playBar\\n    @Input() playBarColor: string;\\n\\n\\n    // relation to Css End\\n\\n    // Video clips\\n    @Input() videoCells: Array<VideoCellType>;\\n\\n    // flag of click play button\\n    @Input() isPlayClick: boolean;\\n\\n    // emit data when click playButton\\n    @Output() readonly playClick: EventEmitter<any>;\\n\\n    // emit data when mouseUp\\n    @Output() readonly mouseUp: EventEmitter<any>;\\n\\n    // emit data when mouseDown\\n    @Output() readonly mouseDown: EventEmitter<any>;\\n\\n    // emit data when keyUp\\n    @Output() readonly keyUp: EventEmitter<any>;\\n\\n    // emit data when keyDown\\n    @Output() readonly keyDown: EventEmitter<any>;\\n\\n    // --- canvas data start ---//\\n\\n    // canvas box\\n    canvas: any;\\n\\n    // canvas context\\n    ctx: any;\\n\\n    // canvas width\\n    canvasW: number;\\n\\n    // canvas height\\n    canvasH: number;\\n\\n    // video clips in reality\\n    timecell: Array<VideoCellType>;\\n\\n    // per minute stand for step\\n    minutesPerStep: Array<number>;\\n\\n    // per minite stand for px\\n    pxPerMs: number;\\n\\n    // Minimum width between scales, unit px\\n    graduationStep: number;\\n\\n    // The timeline shows x hours\\n    hoursPerRuler: number;\\n\\n    // The leftmost timestamp that appears -- the default is the first 12 hours\\n    startTimestamp: number;\\n\\n    // current timestamp\\n    currentTimestamp: number;\\n\\n    // Px two hours apart\\n    distanceBetweenGtitle: number;\\n\\n    // zoom of canvas\\n    zoom: number;\\n\\n    // marker of drag an unreleased mouse event\\n    gIsMousedown: boolean;\\n\\n    // marker of drag the mouse move\\n    gIsMousemove: boolean;\\n\\n    // The position of the X-axis when the mouse is pressed\\n    gMousedownCursor = undefined;\\n\\n    // The position of the y-axis when the mouse is pressed\\n    gMousedownCursorY = undefined;\\n\\n    // Time flow timer\\n    setTimeMove: Subscription;\\n\\n    // The distance to the left of the play button\\n    playBarDistanceLeft: number;\\n\\n    // Play the initial position of the icon\\n    playBarOffsetX: number;\\n\\n    // Play the X-axis position 1 of the icon\\n    playBarOffsetX1: number;\\n\\n    // Play the X-axis position 2 of the icon\\n    playBarOffsetX2: number;\\n\\n    // Play the Y-axis position 1 of the icon\\n    playBarOffsetY1: number;\\n\\n    // Play the Y-axis position 2 of the icon\\n    playBarOffsetY2: number;\\n\\n    // --- canvas data end ---//\\n\\n    // elements of the timeline\\n    @ViewChild('timeline', { static: true }) canvasExp: ElementRef;\\n\\n    constructor() {\\n        // this.startTimeThreshold = new Date().getTime() - 1 * 0.5 * 3600 * 1000;\\n        // this.endTimeThreshold = new Date().getTime() + 1 * 1 * 3600 * 1000;\\n        this.forWardValue = 5000;\\n        this.speed = 1000;\\n        this.playTime = new Date().getTime();\\n        this.startTimeThreshold = new Date().getTime() - 1 * 12 * 3600 * 1000;\\n        this.endTimeThreshold = new Date().getTime() + 1 * 12 * 3600 * 1000;\\n        this.playClick = new EventEmitter<any>();\\n        this.mouseUp = new EventEmitter<any>();\\n        this.mouseDown = new EventEmitter<any>();\\n        this.keyUp = new EventEmitter<any>();\\n        this.keyDown = new EventEmitter<any>();\\n        this.isPlayClick = false;\\n        this.videoCells = [\\n            {\\n                beginTime: new Date().getTime() - 3 * 3600 * 1000,\\n                endTime: new Date().getTime() - 1 * 3600 * 1000,\\n                style: {\\n                    background: 'rgba(132, 244, 180, 0.498039)'\\n                }\\n            },\\n            {\\n                beginTime: new Date().getTime() - 6 * 3600 * 1000,\\n                endTime: new Date().getTime() - 4 * 3600 * 1000,\\n                style: {\\n                    background: 'rgba(132, 244, 180, 0.498039)'\\n                }\\n            }\\n        ];\\n        this.verticalBarColor = 'rgba(0,0,0,1)';\\n        this.bottomLineColor = 'rgba(0,0,0,1)';\\n        this.borderColor = '#fff';\\n        this.bgColor = '#fff';\\n        this.playBarColor = '#448aff';\\n    }\\n\\n    /**\\n     * Browser change event\\n     */\\n    @HostListener('window:resize', [])\\n    onResize(): void {\\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\\n        this.canvasW = this.canvas.parentNode.offsetWidth;\\n        this.init(this.startTimestamp, this.timecell, false);\\n    }\\n\\n    /**\\n     * Keyboard press event\\n     */\\n    @HostListener('window:keydown', ['$event'])\\n    onKeyDown(event: any): void {\\n        if (Number(event.keyCode) === 37) {\\n            this.playTime = Number(this.playTime) - this.forWardValue;\\n            this.currentTimestamp = Number(this.currentTimestamp) - this.forWardValue;\\n            this.set_time_to_middle(this.playTime);\\n\\n        } else if (Number(event.keyCode === 39)) {\\n            this.playTime = Number(this.playTime) + this.forWardValue;\\n            this.currentTimestamp = Number(this.currentTimestamp) + this.forWardValue;\\n            this.set_time_to_middle(this.playTime);\\n        }\\n        this.keyDown.emit(this.playTime);\\n    }\\n\\n    /**\\n     * Keyboard release event\\n     */\\n    @HostListener('window:keyup', ['$event'])\\n    onKeyUp(event: any): void {\\n        if (Number(event.keyCode) === 13 || Number(event.keyCode === 32)) {\\n            this.isPlayClick ? this.onPauseClick() : this.onPlayClick();\\n        }\\n        this.keyUp.emit(this.playTime);\\n    }\\n\\n    ngOnInit(): void {\\n        // Initialize data video group event stamp to show new Date().getTime()- number of hours\\n\\n        // Assign the Canvas DOM to the variable Canvas\\n        this.canvas = this.canvasExp.nativeElement;\\n\\n        // Define the area of the canvas\\n        this.ctx = this.canvas.getContext('2d');\\n\\n        // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\\n\\n        // Store the width and height of the canvas\\n        this.canvasW = this.canvas.width;\\n        this.canvas.height = this.canvasHeight;\\n        this.canvasH = this.canvas.height;\\n\\n        // Assign the video array to Timecell\\n        this.timecell = this.videoCells;\\n\\n        // Initialize the number of steps per minute\\n        this.minutesPerStep = [\\n            1,\\n            2,\\n            5,\\n            10,\\n            15,\\n            20,\\n            30,\\n            60,\\n            120,\\n            180,\\n            240,\\n            360,\\n            720,\\n            1440\\n        ];\\n\\n        // Initialization style\\n\\n        // Minimum width between scales, in units of px 20px\\n        this.graduationStep = 20;\\n\\n        // The timeline shows the time rounded up according to the time threshold\\n        this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\\n            Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) :\\n            24;\\n\\n        // The leftmost timestamp defaults to 12 hours before the current time\\n        this.startTimestamp = Number(this.startTimeThreshold);\\n\\n        // Default distance 80\\n        this.distanceBetweenGtitle = 80;\\n        // Default zoom 24\\n        this.zoom = 24;\\n\\n        // Default false\\n        this.gIsMousedown = false;\\n        this.gIsMousemove = false;\\n        this.gMousedownCursor = undefined;\\n\\n        // px/ms\\n        this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\\n\\n        // The initial X position of the playback icon is in the middle of the scale\\n        this.playBarOffsetX = this.canvasW / 2;\\n\\n        this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\\n        this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\\n\\n        this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\\n        this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\\n        this.playBarOffsetY1 = (this.scale * 2.5);\\n        this.playBarOffsetY2 = ((this.scale * 3.5));\\n\\n        // Initialize the timeline\\n        this.init(this.startTimestamp, this.timecell, false);\\n\\n        // Draw the play button\\n        this.drawPalyBar();\\n    }\\n\\n    ngOnChanges(changes: SimpleChanges): void {\\n        // Refactor the playback component when the width and height change\\n        if (changes.canvasHeight) {\\n            this.canvasHeight = changes.canvasHeight.currentValue;\\n\\n            // Assign the Canvas DOM to the variable Canvas\\n            this.canvas = this.canvasExp.nativeElement;\\n\\n            // Define the area of the canvas\\n            this.ctx = this.canvas.getContext('2d');\\n\\n            // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\\n            this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\\n\\n            // Store the width and height of the canvas\\n            this.canvasW = this.canvas.width;\\n\\n            this.canvas.height = this.canvasHeight;\\n            this.canvasH = this.canvas.height;\\n\\n            // Assign the video array to Timecell\\n            this.timecell = this.videoCells;\\n\\n            this.minutesPerStep = [\\n                1,\\n                2,\\n                5,\\n                10,\\n                15,\\n                20,\\n                30,\\n                60,\\n                120,\\n                180,\\n                240,\\n                360,\\n                720,\\n                1440\\n            ];\\n            // The timeline shows the time rounded up according to the time threshold\\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\\n                Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\\n                : 24;\\n\\n            // The leftmost timestamp defaults to 12 hours before the current time\\n            this.startTimestamp = Number(this.startTimeThreshold);\\n\\n            this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\\n\\n            // The initial X position of the playback icon is in the middle of the scale\\n            this.playBarOffsetX = this.canvasW / 2;\\n\\n            this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\\n            // Current timestamp\\n            this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\\n\\n            this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\\n            this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\\n            this.playBarOffsetY1 = (this.scale * 2.5);\\n            this.playBarOffsetY2 = ((this.scale * 3.5));\\n\\n            this.init(this.startTimestamp, this.timecell, false);\\n            this.drawPalyBar();\\n        }\\n        if (changes.videoCells) {\\n            this.videoCells = changes.videoCells.currentValue;\\n\\n            this.timecell = this.videoCells;\\n            this.add_cells(this.timecell);\\n\\n            // this.init(this.startTimestamp, this.timecell, true);\\n            // this.drawPalyBar();\\n        }\\n        if (changes.startTimeThreshold) {\\n            const value = changes.startTimeThreshold.currentValue;\\n            if (changes.startTimeThreshold.currentValue instanceof String) {\\n                this.startTimeThreshold = new Date(value).getTime();\\n            } else if (value instanceof Date) {\\n                this.startTimeThreshold = value.getTime();\\n            } else if (typeof value === 'number') {\\n                this.startTimeThreshold = Number(value);\\n            }\\n\\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\\n                : 24;\\n\\n            this.startTimestamp = Number(this.startTimeThreshold);\\n            // this.init(this.startTimestamp, this.timecell, false);\\n        }\\n        if (changes.endTimeThreshold) {\\n            const value = changes.endTimeThreshold.currentValue;\\n            if (changes.endTimeThreshold.currentValue instanceof String) {\\n                this.endTimeThreshold = new Date(value).getTime();\\n            } else if (value instanceof Date) {\\n                this.endTimeThreshold = value.getTime();\\n            } else if (typeof value === 'number') {\\n                this.endTimeThreshold = Number(value);\\n            }\\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\\n                : 24;\\n\\n        }\\n        if (changes.playTime) {\\n\\n            const value = changes.playTime.currentValue;\\n            if (changes.playTime.currentValue instanceof String) {\\n                this.playTime = new Date(value).getTime();\\n            } else if (value instanceof Date) {\\n                this.playTime = value.getTime();\\n            } else if (typeof value === 'number') {\\n                this.playTime = Number(value);\\n            }\\n\\n            // use SetTimeOut Timer to make it  asynchronous\\n            setTimeout(() => {\\n                this.set_time_to_middle(new Date(this.playTime).getTime());\\n            }, 100);\\n\\n        }\\n        if (changes.speed) {\\n\\n            this.speed = Number(changes.speed.currentValue) * 1000;\\n        }\\n        if (changes.forWardValue) {\\n\\n            this.forWardValue = Number(changes.forWardValue.currentValue) * 1000;\\n        }\\n\\n        if (changes.isPlayClick) {\\n            if (changes.isPlayClick.currentValue) {\\n                this.onPlayClick();\\n            } else {\\n                this.onPauseClick();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Initialize\\n     * @param  startTimestamp Leftmost time\\n     * @param  timecell Video segment array\\n     * @param  redrawFlag Whether to redraw the mark\\n     */\\n    init(startTimestamp: number, timecell: any, redrawFlag: boolean): void {\\n        this.timecell = timecell;\\n        this.startTimestamp = startTimestamp;\\n        if (\\n            this.currentTimestamp >=\\n            this.endTimeThreshold\\n        ) {\\n            this.startTimestamp =\\n                Number(this.endTimeThreshold) -\\n                (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n            this.currentTimestamp =\\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n            this.playTime =\\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n        } else if (\\n            this.currentTimestamp <=\\n            this.startTimeThreshold\\n        ) {\\n            this.startTimestamp =\\n                Number(this.startTimeThreshold) -\\n                (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n            this.currentTimestamp =\\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n            this.playTime =\\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n        }\\n        this.drawCellBg();\\n        this.add_graduations(startTimestamp);\\n        this.add_cells(timecell);\\n        // Draw the verticalBar\\n        this.drawLine(\\n            0,\\n            this.canvasH,\\n            this.canvasW,\\n            this.canvasH,\\n            this.bottomLineColor,\\n            1\\n        );\\n    }\\n\\n    /**\\n     * Draw add scale\\n     * @param  startTimestamp Leftmost time\\n     */\\n    add_graduations(startTimestamp: number): void {\\n        // px/min\\n        const pxPerMin = this.canvasW / (this.hoursPerRuler * 60);\\n        // px/ms\\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000);\\n        // The default minimum value of PX/steo is 20px\\n        let pxPerStep = this.graduationStep;\\n\\n        // Min/steo\\n        let minPerStep = pxPerStep / pxPerMin;\\n\\n        for (const v of this.minutesPerStep) {\\n            if (minPerStep <= v) {\\n                // Keep each cell within the range specified by minutesPerStep\\n                minPerStep = v;\\n                pxPerStep = pxPerMin * minPerStep;\\n                break;\\n            }\\n        }\\n        let mediumStep = 30;\\n        for (const v of this.minutesPerStep) {\\n            if (this.distanceBetweenGtitle / pxPerMin <= v) {\\n                mediumStep = v;\\n                break;\\n            }\\n        }\\n        // The total number\\n        const numSteps = this.canvasW / pxPerStep;\\n\\n        let graduationLeft: number;\\n        let graduationTime: number;\\n\\n        let caretClass: string;\\n        let lineH: number;\\n\\n        // The initial offset time (ms)\\n        const msOffset = this.ms_to_next_step(\\n            startTimestamp,\\n            minPerStep * 60 * 1000\\n        );\\n\\n        // The initial offset is (px)\\n        const pxOffset = msOffset * pxPerMs;\\n\\n        // ms/step\\n        const msPerStep = pxPerStep / pxPerMs;\\n\\n        for (let i = 0; i < numSteps; i++) {\\n            // Distance = offset distance to start + steps *px/ steps\\n            graduationLeft = pxOffset + i * pxPerStep;\\n\\n            // Time = left start time + offset time + steps *ms/ steps\\n            graduationTime =\\n                Number(startTimestamp) +\\n                Number(msOffset) +\\n                i * Number(msPerStep);\\n\\n            const date = new Date(graduationTime);\\n            if (date.getUTCHours() === 0 && date.getUTCMinutes() === 0) {\\n                caretClass = 'big';\\n                lineH = (this.scale * 1.25);\\n                const bigDate = DateUtil.formatDate(date, 'HH:mm:ss');\\n                this.ctx.textAlign = 'center';\\n                this.ctx.fillText(bigDate, graduationLeft, (this.scale * 1.5));\\n                this.ctx.fillStyle = this.verticalBarColor;\\n            } else if ((graduationTime / (60 * 1000)) % mediumStep === 0) {\\n                caretClass = 'middle';\\n                lineH = (this.scale * 0.75);\\n                const middleDate = DateUtil.formatDate(date, 'HH:mm:ss');\\n                this.ctx.textAlign = 'center';\\n                this.ctx.fillText(middleDate, graduationLeft, (this.scale * 1.5));\\n                this.ctx.fillStyle = this.verticalBarColor;\\n            } else {\\n                lineH = (this.scale * 0.5);\\n            }\\n            // drawLine(graduationLeft,0,graduationLeft,lineH,\\\"rgba(151,158,167,0.4)\\\",1);\\n            this.drawLine(\\n                graduationLeft,\\n                0,\\n                graduationLeft,\\n                lineH,\\n                this.verticalBarColor,\\n                1\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Draw the play button\\n     */\\n    drawPalyBar(): void {\\n        this.ctx.beginPath();\\n        this.ctx.moveTo(this.playBarOffsetX, 0);\\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\\n        this.ctx.strokeStyle = this.playBarColor;\\n        this.ctx.stroke();\\n        this.ctx.moveTo(this.playBarOffsetX, (this.scale * 1.75));\\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 2.5));\\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 3.5));\\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 3.5));\\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 2.5));\\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\\n        this.ctx.fillStyle = this.playBarColor;\\n        this.ctx.fill();\\n        this.ctx.closePath();\\n        // this.init(this.startTimestamp, this.timecell, false);\\n        const time = Number(this.currentTimestamp);\\n        this.ctx.fillStyle = this.playBarColor;\\n        this.ctx.textAlign = 'center';\\n        this.ctx.fillText(\\n            DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'),\\n            this.playBarOffsetX,\\n            (this.scale * 4.25)\\n        );\\n    }\\n\\n    /**\\n     * Draw the line\\n     * @param  beginX The X-axis to start with\\n     * @param  beginY The Y-axis to start with\\n     * @param  endX The end of the X-axis\\n     * @param  endY The end of the Y-axis\\n     * @param  color color\\n     * @param  width width\\n     */\\n    drawLine(\\n        beginX: number,\\n        beginY: number,\\n        endX: number,\\n        endY: number,\\n        color: string,\\n        width: number\\n    ): void {\\n        this.ctx.beginPath();\\n        this.ctx.moveTo(beginX, beginY);\\n        this.ctx.lineTo(endX, endY);\\n        this.ctx.strokeStyle = color;\\n        this.ctx.lineWidth = width;\\n        this.ctx.stroke();\\n    }\\n\\n    /**\\n     * Add video segment\\n     * @param  cells Video array\\n     */\\n    add_cells(cells: any): void {\\n        cells.forEach((cell: MouseEvent) => {\\n            this.draw_cell(cell);\\n        });\\n    }\\n\\n    /**\\n     * Draw video blocks\\n     * @param  cell The cell includes beginTime Ms; The endTime ms; style;\\n     */\\n    draw_cell(cell: any): void {\\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000); // px/ms\\n        const beginX = (cell.beginTime - this.startTimestamp) * pxPerMs;\\n        const cellWidth = (cell.endTime - cell.beginTime) * pxPerMs;\\n        this.ctx.fillStyle = cell.style.background;\\n        this.ctx.fillRect(beginX, 0, cellWidth, (this.scale * 0.75));\\n    }\\n\\n    /**\\n     * Draws the background of the video block\\n     */\\n    drawCellBg(): void {\\n        this.ctx.fillStyle = 'rgba(69, 72, 76, 0.5)';\\n        this.ctx.fillRect(0, 0, this.canvasW, 0);\\n    }\\n\\n    /**\\n     * Drag/click the Mousedown event\\n     */\\n    mousedownFunc(e: MouseEvent): void {\\n        this.gIsMousedown = true;\\n        this.gMousedownCursor = this.get_cursor_x_position(e).posX;\\n        this.gMousedownCursorY = this.get_cursor_x_position(e).posY;\\n    }\\n\\n    /**\\n     * Drag/mouse hover to display mousemove events\\n     */\\n    mousemoveFunc(e: MouseEvent): void {\\n        this.clearCanvas();\\n        const posX = this.get_cursor_x_position(e).posX;\\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\\n        const diffX = posX - this.gMousedownCursor;\\n        if (this.gIsMousedown) {\\n            if (\\n                this.gMousedownCursor >= this.playBarOffsetX1 &&\\n                this.gMousedownCursor <= this.playBarOffsetX2 &&\\n                this.gMousedownCursorY >= this.playBarOffsetY1 &&\\n                this.gMousedownCursorY <= this.playBarOffsetY2\\n            ) {\\n                // this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\\n                // this.playBarOffsetX = posX;\\n                // this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\\n                // this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\\n\\n                this.startTimestamp =\\n                    this.startTimestamp + Math.round(diffX / pxPerMs);\\n\\n                this.currentTimestamp =\\n                    (this.startTimestamp +\\n                        Math.round(this.playBarOffsetX / pxPerMs));\\n\\n                this.drawPalyBar();\\n                this.init(this.startTimestamp, this.timecell, false);\\n\\n                this.gIsMousemove = true;\\n\\n            } else {\\n                this.startTimestamp =\\n                    this.startTimestamp - Math.round(diffX / pxPerMs);\\n\\n                this.currentTimestamp =\\n                    this.startTimestamp +\\n                    Math.round(this.playBarOffsetX / pxPerMs);\\n\\n                this.drawPalyBar();\\n                this.init(this.startTimestamp, this.timecell, true);\\n\\n                this.gIsMousemove = true;\\n                this.gMousedownCursor = posX;\\n\\n            }\\n            this.mouseUp.emit(this.currentTimestamp);\\n\\n        } else {\\n\\n            const time = this.startTimestamp + posX / pxPerMs;\\n\\n            this.drawPalyBar();\\n            this.init(this.startTimestamp, this.timecell, true);\\n            this.drawLine(posX, 0, posX, 50, 'rgb(194, 202, 215)', 1);\\n\\n            this.ctx.fillStyle = 'rgb(194, 202, 215)';\\n            this.ctx.textAlign = 'center';\\n            this.ctx.fillText(\\n                DateUtil.formatDate(\\n                    new Date(time),\\n                    'YYYY-MM-DD HH:mm:ss'\\n                ),\\n                posX,\\n                (this.scale * 3)\\n            );\\n\\n        }\\n    }\\n\\n    /**\\n     * Drag/click the Mouseup event\\n     */\\n    mouseupFunc(e: MouseEvent): void {\\n        if (this.gIsMousemove) {\\n            // Drag events\\n            this.gIsMousemove = false;\\n            this.gIsMousedown = false;\\n            this.playTime =\\n                this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\\n        } else {\\n            // Click event\\n            this.gIsMousedown = false;\\n\\n            // Mouse distance (px)\\n            const posx = this.get_cursor_x_position(e).posX;\\n\\n            // ms/px\\n            const msPerPx = (this.zoom * 3600 * 1000) / this.canvasW;\\n\\n            this.playTime = this.startTimestamp + posx * msPerPx;\\n            this.set_time_to_middle(this.playTime);\\n\\n        }\\n        this.mouseDown.emit(this.playTime);\\n    }\\n\\n    /**\\n     * Mouseout of the hidden time mouseout event\\n     */\\n    mouseoutFunc(): void {\\n        this.clearCanvas();\\n        // px/ms\\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\\n        this.currentTimestamp =\\n            this.startTimestamp +\\n            Math.round(this.playBarOffsetX / pxPerMs);\\n\\n        this.drawPalyBar();\\n        this.init(this.startTimestamp, this.timecell, true);\\n    }\\n\\n    /**\\n     * Scroll to the center of the timeline for the mousewheel event\\n     */\\n    mousewheelFunc(event: any): boolean {\\n        if (event && event.preventDefault) {\\n            event.preventDefault();\\n        } else {\\n            window.event.returnValue = false;\\n            return false;\\n        }\\n\\n        const e = window.event || event;\\n        const delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));\\n\\n        // Ms Remember the current middle time\\n        const middleTime =\\n            this.startTimestamp + (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\\n        if (delta < 0) {\\n            this.zoom = this.zoom + 4;\\n            if (this.zoom >= 24) {\\n                // Shrink to a minimum of 24 hours\\n                this.zoom = 24;\\n            }\\n            this.hoursPerRuler = this.zoom;\\n        } else if (delta > 0) {\\n            // amplification\\n            this.zoom = this.zoom - 4;\\n            if (this.zoom <= 1) {\\n                // Zoom in at most one hour\\n                this.zoom = 1;\\n            }\\n            this.hoursPerRuler = this.zoom;\\n        }\\n\\n        this.clearCanvas();\\n        // // startTimestamp = current middle time - zoom /2\\n        this.startTimestamp =\\n            middleTime - (this.hoursPerRuler * 3600 * 1000) / 2;\\n\\n        this.init(this.startTimestamp, this.timecell, true);\\n        this.drawPalyBar();\\n    }\\n\\n    /**\\n     * Get the mouse POSx\\n     * @param  e event\\n     */\\n    get_cursor_x_position(e: any): CanvasPos {\\n        let posx = 0;\\n        let posy = 0;\\n\\n        if (!e) {\\n            e = window.event;\\n        }\\n        if (e.offsetX || e.offsetY) {\\n            posx = e.offsetX;\\n            posy = e.offsetY;\\n        }\\n\\n        return { posX: posx, posY: posy };\\n    }\\n\\n    /**\\n     * The offset of the left start time, returns the unit ms\\n     * @param  timestamp The time stamp\\n     * @param  step The offset\\n     */\\n    ms_to_next_step(timestamp: number, step: number): number {\\n        const remainder = timestamp % step;\\n        return remainder ? step - remainder : 0;\\n    }\\n\\n    /**\\n     * Set the time to jump to the middle red line\\n     *  @param  time Unit of ms\\n     */\\n    set_time_to_middle(time: number): void {\\n        if (this.ctx) {\\n            this.clearCanvas();\\n            this.startTimestamp = time - (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\\n            this.currentTimestamp = time;\\n            this.drawPalyBar();\\n            this.init(this.startTimestamp, this.timecell, true);\\n        }\\n    }\\n\\n    /**\\n     * 清除canvas 每次重新绘制需要先清除\\n     */\\n    clearCanvas(): void {\\n        this.ctx.clearRect(0, 0, this.canvasW, (this.scale * 7.5));\\n    }\\n    /**\\n     * Click to play\\n     */\\n\\n    onPlayClick(): void {\\n        // this.setTimeMove = undefined;\\n        this.isPlayClick = true;\\n        this.setTimeMove = interval(this.speed).subscribe((d: any) => {\\n            this.playTime = Number(this.playTime) + 1 * 1000;\\n            this.playClick.emit(this.playTime);\\n            this.set_time_to_middle(this.playTime);\\n        });\\n    }\\n    /**\\n     * Click on the pause\\n     */\\n    onPauseClick(): void {\\n        this.isPlayClick = false;\\n        if (this.setTimeMove) {\\n            // this.setTimeMove = undefined;\\n            this.setTimeMove.unsubscribe();\\n            this.playClick.emit(this.playTime);\\n        }\\n    }\\n    /**\\n     * Change video segment\\n     */\\n    changeVideo(): void {\\n        const cells: Array<VideoCellType> = [\\n            {\\n                beginTime: new Date().getTime() - 1 * 1000 * 3600,\\n                endTime: new Date().getTime() + 2 * 1000 * 3600,\\n                style: {\\n                    background: 'rgba(132, 244, 180, 0.498039)'\\n                }\\n            }\\n        ];\\n        this.clearCanvas();\\n        this.drawPalyBar();\\n        this.init(this.startTimestamp, cells, true);\\n    }\\n\\n    /**\\n     * Temporary unused\\n     * @param event MatDatepickerInputEvent(Date)\\n     */\\n    selectedTime(event: any): void {\\n        const timestamp = new Date(event.value.getTime());\\n        this.set_time_to_middle(Number(timestamp));\\n    }\\n\\n    /**\\n     * Temporary unused\\n     * @param event MouseEvent\\n     */\\n    onDragStart(e: MouseEvent): boolean {\\n        e.preventDefault();\\n        return false;\\n    }\\n\\n\\n}\\n\",\"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\",\"import { NgModule } from '@angular/core';\\nimport { NgxVideoTimelineComponent } from './timeline.component';\\nimport { CommonModule } from '@angular/common';\\n\\n\\n\\n@NgModule({\\n    declarations: [NgxVideoTimelineComponent],\\n    imports: [\\n      CommonModule\\n    ],\\n    exports: [NgxVideoTimelineComponent]\\n})\\nexport class NgxVideoTimelineModule { }\\n\",\"/*\\n * Public API Surface of timeline\\n */\\n\\nexport * from './lib/timeline.component';\\nexport * from './lib/timeline.module';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}],"fesm2015":[{"exports":["DateUtil","NgxVideoTimelineComponent","NgxVideoTimelineModule"],"facadeModuleId":"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/ngx-video-timeline.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/lib/timeline.component.mjs","/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/lib/timeline.module.mjs","/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/public-api.mjs","/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/ngx-video-timeline.mjs"],"name":"ngx-video-timeline","type":"chunk","dynamicImports":[],"fileName":"ngx-video-timeline.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["EventEmitter","*","Component","Input","Output","ViewChild","HostListener","NgModule"],"rxjs":["interval"],"@angular/common":["*","CommonModule"]},"imports":["@angular/core","rxjs","@angular/common"],"modules":{"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/lib/timeline.component.mjs":{"code":"/**\n * A utility class for working with dates.\n */\nclass DateUtil {\n    /**\n     * Formats the given date according to the specified format.\n     * @param date The date to format.\n     * @param format The format string, using the following placeholders:\n     *   - YYYY: four-digit year\n     *   - MM: two-digit month (zero-padded)\n     *   - DD: two-digit day of month (zero-padded)\n     *   - HH: two-digit hour (zero-padded, 24-hour format)\n     *   - mm: two-digit minute (zero-padded)\n     *   - ss: two-digit second (zero-padded)\n     * @returns The formatted date string.\n     */\n    static formatDate(date, format) {\n        // Extract the year, month, day, hours, minutes, and seconds from the date\n        const year = date.getFullYear().toString();\n        const month = (date.getMonth() + 1).toString().padStart(2, '0');\n        const day = date.getDate().toString().padStart(2, '0');\n        const hours = date.getHours().toString().padStart(2, '0');\n        const minutes = date.getMinutes().toString().padStart(2, '0');\n        const seconds = date.getSeconds().toString().padStart(2, '0');\n        // Replace the placeholders in the format string with the corresponding date parts\n        return format\n            .replace('YYYY', year)\n            .replace('MM', month)\n            .replace('DD', day)\n            .replace('HH', hours)\n            .replace('mm', minutes)\n            .replace('ss', seconds);\n    }\n}\nclass NgxVideoTimelineComponent {\n    constructor() {\n        // The height of the outer canvas\n        this.canvasHeight = 50;\n        // Canvas scale is adjusted according to outer height\n        this.scale = this.canvasHeight / 4.55;\n        // The position of the X-axis when the mouse is pressed\n        this.gMousedownCursor = undefined;\n        // The position of the y-axis when the mouse is pressed\n        this.gMousedownCursorY = undefined;\n        // this.startTimeThreshold = new Date().getTime() - 1 * 0.5 * 3600 * 1000;\n        // this.endTimeThreshold = new Date().getTime() + 1 * 1 * 3600 * 1000;\n        this.forWardValue = 5000;\n        this.speed = 1000;\n        this.playTime = new Date().getTime();\n        this.startTimeThreshold = new Date().getTime() - 1 * 12 * 3600 * 1000;\n        this.endTimeThreshold = new Date().getTime() + 1 * 12 * 3600 * 1000;\n        this.playClick = new EventEmitter();\n        this.mouseUp = new EventEmitter();\n        this.mouseDown = new EventEmitter();\n        this.keyUp = new EventEmitter();\n        this.keyDown = new EventEmitter();\n        this.isPlayClick = false;\n        this.videoCells = [\n            {\n                beginTime: new Date().getTime() - 3 * 3600 * 1000,\n                endTime: new Date().getTime() - 1 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            },\n            {\n                beginTime: new Date().getTime() - 6 * 3600 * 1000,\n                endTime: new Date().getTime() - 4 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.verticalBarColor = 'rgba(0,0,0,1)';\n        this.bottomLineColor = 'rgba(0,0,0,1)';\n        this.borderColor = '#fff';\n        this.bgColor = '#fff';\n        this.playBarColor = '#448aff';\n    }\n    /**\n     * Browser change event\n     */\n    onResize() {\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        this.canvasW = this.canvas.parentNode.offsetWidth;\n        this.init(this.startTimestamp, this.timecell, false);\n    }\n    /**\n     * Keyboard press event\n     */\n    onKeyDown(event) {\n        if (Number(event.keyCode) === 37) {\n            this.playTime = Number(this.playTime) - this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) - this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        else if (Number(event.keyCode === 39)) {\n            this.playTime = Number(this.playTime) + this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) + this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.keyDown.emit(this.playTime);\n    }\n    /**\n     * Keyboard release event\n     */\n    onKeyUp(event) {\n        if (Number(event.keyCode) === 13 || Number(event.keyCode === 32)) {\n            this.isPlayClick ? this.onPauseClick() : this.onPlayClick();\n        }\n        this.keyUp.emit(this.playTime);\n    }\n    ngOnInit() {\n        // Initialize data video group event stamp to show new Date().getTime()- number of hours\n        // Assign the Canvas DOM to the variable Canvas\n        this.canvas = this.canvasExp.nativeElement;\n        // Define the area of the canvas\n        this.ctx = this.canvas.getContext('2d');\n        // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        // Store the width and height of the canvas\n        this.canvasW = this.canvas.width;\n        this.canvas.height = this.canvasHeight;\n        this.canvasH = this.canvas.height;\n        // Assign the video array to Timecell\n        this.timecell = this.videoCells;\n        // Initialize the number of steps per minute\n        this.minutesPerStep = [\n            1,\n            2,\n            5,\n            10,\n            15,\n            20,\n            30,\n            60,\n            120,\n            180,\n            240,\n            360,\n            720,\n            1440\n        ];\n        // Initialization style\n        // Minimum width between scales, in units of px 20px\n        this.graduationStep = 20;\n        // The timeline shows the time rounded up according to the time threshold\n        this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n            Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) :\n            24;\n        // The leftmost timestamp defaults to 12 hours before the current time\n        this.startTimestamp = Number(this.startTimeThreshold);\n        // Default distance 80\n        this.distanceBetweenGtitle = 80;\n        // Default zoom 24\n        this.zoom = 24;\n        // Default false\n        this.gIsMousedown = false;\n        this.gIsMousemove = false;\n        this.gMousedownCursor = undefined;\n        // px/ms\n        this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        // The initial X position of the playback icon is in the middle of the scale\n        this.playBarOffsetX = this.canvasW / 2;\n        this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n        this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n        this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n        this.playBarOffsetY1 = (this.scale * 2.5);\n        this.playBarOffsetY2 = ((this.scale * 3.5));\n        // Initialize the timeline\n        this.init(this.startTimestamp, this.timecell, false);\n        // Draw the play button\n        this.drawPalyBar();\n    }\n    ngOnChanges(changes) {\n        // Refactor the playback component when the width and height change\n        if (changes.canvasHeight) {\n            this.canvasHeight = changes.canvasHeight.currentValue;\n            // Assign the Canvas DOM to the variable Canvas\n            this.canvas = this.canvasExp.nativeElement;\n            // Define the area of the canvas\n            this.ctx = this.canvas.getContext('2d');\n            // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n            this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n            // Store the width and height of the canvas\n            this.canvasW = this.canvas.width;\n            this.canvas.height = this.canvasHeight;\n            this.canvasH = this.canvas.height;\n            // Assign the video array to Timecell\n            this.timecell = this.videoCells;\n            this.minutesPerStep = [\n                1,\n                2,\n                5,\n                10,\n                15,\n                20,\n                30,\n                60,\n                120,\n                180,\n                240,\n                360,\n                720,\n                1440\n            ];\n            // The timeline shows the time rounded up according to the time threshold\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n                Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            // The leftmost timestamp defaults to 12 hours before the current time\n            this.startTimestamp = Number(this.startTimeThreshold);\n            this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n            // The initial X position of the playback icon is in the middle of the scale\n            this.playBarOffsetX = this.canvasW / 2;\n            this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n            // Current timestamp\n            this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n            this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n            this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n            this.playBarOffsetY1 = (this.scale * 2.5);\n            this.playBarOffsetY2 = ((this.scale * 3.5));\n            this.init(this.startTimestamp, this.timecell, false);\n            this.drawPalyBar();\n        }\n        if (changes.videoCells) {\n            this.videoCells = changes.videoCells.currentValue;\n            this.timecell = this.videoCells;\n            this.add_cells(this.timecell);\n            // this.init(this.startTimestamp, this.timecell, true);\n            // this.drawPalyBar();\n        }\n        if (changes.startTimeThreshold) {\n            const value = changes.startTimeThreshold.currentValue;\n            if (changes.startTimeThreshold.currentValue instanceof String) {\n                this.startTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.startTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.startTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            this.startTimestamp = Number(this.startTimeThreshold);\n            // this.init(this.startTimestamp, this.timecell, false);\n        }\n        if (changes.endTimeThreshold) {\n            const value = changes.endTimeThreshold.currentValue;\n            if (changes.endTimeThreshold.currentValue instanceof String) {\n                this.endTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.endTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.endTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n        }\n        if (changes.playTime) {\n            const value = changes.playTime.currentValue;\n            if (changes.playTime.currentValue instanceof String) {\n                this.playTime = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.playTime = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.playTime = Number(value);\n            }\n            // use SetTimeOut Timer to make it  asynchronous\n            setTimeout(() => {\n                this.set_time_to_middle(new Date(this.playTime).getTime());\n            }, 100);\n        }\n        if (changes.speed) {\n            this.speed = Number(changes.speed.currentValue) * 1000;\n        }\n        if (changes.forWardValue) {\n            this.forWardValue = Number(changes.forWardValue.currentValue) * 1000;\n        }\n        if (changes.isPlayClick) {\n            if (changes.isPlayClick.currentValue) {\n                this.onPlayClick();\n            }\n            else {\n                this.onPauseClick();\n            }\n        }\n    }\n    /**\n     * Initialize\n     * @param  startTimestamp Leftmost time\n     * @param  timecell Video segment array\n     * @param  redrawFlag Whether to redraw the mark\n     */\n    init(startTimestamp, timecell, redrawFlag) {\n        this.timecell = timecell;\n        this.startTimestamp = startTimestamp;\n        if (this.currentTimestamp >=\n            this.endTimeThreshold) {\n            this.startTimestamp =\n                Number(this.endTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        else if (this.currentTimestamp <=\n            this.startTimeThreshold) {\n            this.startTimestamp =\n                Number(this.startTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        this.drawCellBg();\n        this.add_graduations(startTimestamp);\n        this.add_cells(timecell);\n        // Draw the verticalBar\n        this.drawLine(0, this.canvasH, this.canvasW, this.canvasH, this.bottomLineColor, 1);\n    }\n    /**\n     * Draw add scale\n     * @param  startTimestamp Leftmost time\n     */\n    add_graduations(startTimestamp) {\n        // px/min\n        const pxPerMin = this.canvasW / (this.hoursPerRuler * 60);\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000);\n        // The default minimum value of PX/steo is 20px\n        let pxPerStep = this.graduationStep;\n        // Min/steo\n        let minPerStep = pxPerStep / pxPerMin;\n        for (const v of this.minutesPerStep) {\n            if (minPerStep <= v) {\n                // Keep each cell within the range specified by minutesPerStep\n                minPerStep = v;\n                pxPerStep = pxPerMin * minPerStep;\n                break;\n            }\n        }\n        let mediumStep = 30;\n        for (const v of this.minutesPerStep) {\n            if (this.distanceBetweenGtitle / pxPerMin <= v) {\n                mediumStep = v;\n                break;\n            }\n        }\n        // The total number\n        const numSteps = this.canvasW / pxPerStep;\n        let graduationLeft;\n        let graduationTime;\n        let caretClass;\n        let lineH;\n        // The initial offset time (ms)\n        const msOffset = this.ms_to_next_step(startTimestamp, minPerStep * 60 * 1000);\n        // The initial offset is (px)\n        const pxOffset = msOffset * pxPerMs;\n        // ms/step\n        const msPerStep = pxPerStep / pxPerMs;\n        for (let i = 0; i < numSteps; i++) {\n            // Distance = offset distance to start + steps *px/ steps\n            graduationLeft = pxOffset + i * pxPerStep;\n            // Time = left start time + offset time + steps *ms/ steps\n            graduationTime =\n                Number(startTimestamp) +\n                    Number(msOffset) +\n                    i * Number(msPerStep);\n            const date = new Date(graduationTime);\n            if (date.getUTCHours() === 0 && date.getUTCMinutes() === 0) {\n                caretClass = 'big';\n                lineH = (this.scale * 1.25);\n                const bigDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(bigDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else if ((graduationTime / (60 * 1000)) % mediumStep === 0) {\n                caretClass = 'middle';\n                lineH = (this.scale * 0.75);\n                const middleDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(middleDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else {\n                lineH = (this.scale * 0.5);\n            }\n            // drawLine(graduationLeft,0,graduationLeft,lineH,\"rgba(151,158,167,0.4)\",1);\n            this.drawLine(graduationLeft, 0, graduationLeft, lineH, this.verticalBarColor, 1);\n        }\n    }\n    /**\n     * Draw the play button\n     */\n    drawPalyBar() {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.playBarOffsetX, 0);\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.strokeStyle = this.playBarColor;\n        this.ctx.stroke();\n        this.ctx.moveTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.fill();\n        this.ctx.closePath();\n        // this.init(this.startTimestamp, this.timecell, false);\n        const time = Number(this.currentTimestamp);\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), this.playBarOffsetX, (this.scale * 4.25));\n    }\n    /**\n     * Draw the line\n     * @param  beginX The X-axis to start with\n     * @param  beginY The Y-axis to start with\n     * @param  endX The end of the X-axis\n     * @param  endY The end of the Y-axis\n     * @param  color color\n     * @param  width width\n     */\n    drawLine(beginX, beginY, endX, endY, color, width) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(beginX, beginY);\n        this.ctx.lineTo(endX, endY);\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = width;\n        this.ctx.stroke();\n    }\n    /**\n     * Add video segment\n     * @param  cells Video array\n     */\n    add_cells(cells) {\n        cells.forEach((cell) => {\n            this.draw_cell(cell);\n        });\n    }\n    /**\n     * Draw video blocks\n     * @param  cell The cell includes beginTime Ms; The endTime ms; style;\n     */\n    draw_cell(cell) {\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000); // px/ms\n        const beginX = (cell.beginTime - this.startTimestamp) * pxPerMs;\n        const cellWidth = (cell.endTime - cell.beginTime) * pxPerMs;\n        this.ctx.fillStyle = cell.style.background;\n        this.ctx.fillRect(beginX, 0, cellWidth, (this.scale * 0.75));\n    }\n    /**\n     * Draws the background of the video block\n     */\n    drawCellBg() {\n        this.ctx.fillStyle = 'rgba(69, 72, 76, 0.5)';\n        this.ctx.fillRect(0, 0, this.canvasW, 0);\n    }\n    /**\n     * Drag/click the Mousedown event\n     */\n    mousedownFunc(e) {\n        this.gIsMousedown = true;\n        this.gMousedownCursor = this.get_cursor_x_position(e).posX;\n        this.gMousedownCursorY = this.get_cursor_x_position(e).posY;\n    }\n    /**\n     * Drag/mouse hover to display mousemove events\n     */\n    mousemoveFunc(e) {\n        this.clearCanvas();\n        const posX = this.get_cursor_x_position(e).posX;\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        const diffX = posX - this.gMousedownCursor;\n        if (this.gIsMousedown) {\n            if (this.gMousedownCursor >= this.playBarOffsetX1 &&\n                this.gMousedownCursor <= this.playBarOffsetX2 &&\n                this.gMousedownCursorY >= this.playBarOffsetY1 &&\n                this.gMousedownCursorY <= this.playBarOffsetY2) {\n                // this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n                // this.playBarOffsetX = posX;\n                // this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n                // this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n                this.startTimestamp =\n                    this.startTimestamp + Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    (this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs));\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, false);\n                this.gIsMousemove = true;\n            }\n            else {\n                this.startTimestamp =\n                    this.startTimestamp - Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs);\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, true);\n                this.gIsMousemove = true;\n                this.gMousedownCursor = posX;\n            }\n            this.mouseUp.emit(this.currentTimestamp);\n        }\n        else {\n            const time = this.startTimestamp + posX / pxPerMs;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n            this.drawLine(posX, 0, posX, 50, 'rgb(194, 202, 215)', 1);\n            this.ctx.fillStyle = 'rgb(194, 202, 215)';\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), posX, (this.scale * 3));\n        }\n    }\n    /**\n     * Drag/click the Mouseup event\n     */\n    mouseupFunc(e) {\n        if (this.gIsMousemove) {\n            // Drag events\n            this.gIsMousemove = false;\n            this.gIsMousedown = false;\n            this.playTime =\n                this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        }\n        else {\n            // Click event\n            this.gIsMousedown = false;\n            // Mouse distance (px)\n            const posx = this.get_cursor_x_position(e).posX;\n            // ms/px\n            const msPerPx = (this.zoom * 3600 * 1000) / this.canvasW;\n            this.playTime = this.startTimestamp + posx * msPerPx;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.mouseDown.emit(this.playTime);\n    }\n    /**\n     * Mouseout of the hidden time mouseout event\n     */\n    mouseoutFunc() {\n        this.clearCanvas();\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        this.currentTimestamp =\n            this.startTimestamp +\n                Math.round(this.playBarOffsetX / pxPerMs);\n        this.drawPalyBar();\n        this.init(this.startTimestamp, this.timecell, true);\n    }\n    /**\n     * Scroll to the center of the timeline for the mousewheel event\n     */\n    mousewheelFunc(event) {\n        if (event && event.preventDefault) {\n            event.preventDefault();\n        }\n        else {\n            window.event.returnValue = false;\n            return false;\n        }\n        const e = window.event || event;\n        const delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));\n        // Ms Remember the current middle time\n        const middleTime = this.startTimestamp + (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n        if (delta < 0) {\n            this.zoom = this.zoom + 4;\n            if (this.zoom >= 24) {\n                // Shrink to a minimum of 24 hours\n                this.zoom = 24;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        else if (delta > 0) {\n            // amplification\n            this.zoom = this.zoom - 4;\n            if (this.zoom <= 1) {\n                // Zoom in at most one hour\n                this.zoom = 1;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        this.clearCanvas();\n        // // startTimestamp = current middle time - zoom /2\n        this.startTimestamp =\n            middleTime - (this.hoursPerRuler * 3600 * 1000) / 2;\n        this.init(this.startTimestamp, this.timecell, true);\n        this.drawPalyBar();\n    }\n    /**\n     * Get the mouse POSx\n     * @param  e event\n     */\n    get_cursor_x_position(e) {\n        let posx = 0;\n        let posy = 0;\n        if (!e) {\n            e = window.event;\n        }\n        if (e.offsetX || e.offsetY) {\n            posx = e.offsetX;\n            posy = e.offsetY;\n        }\n        return { posX: posx, posY: posy };\n    }\n    /**\n     * The offset of the left start time, returns the unit ms\n     * @param  timestamp The time stamp\n     * @param  step The offset\n     */\n    ms_to_next_step(timestamp, step) {\n        const remainder = timestamp % step;\n        return remainder ? step - remainder : 0;\n    }\n    /**\n     * Set the time to jump to the middle red line\n     *  @param  time Unit of ms\n     */\n    set_time_to_middle(time) {\n        if (this.ctx) {\n            this.clearCanvas();\n            this.startTimestamp = time - (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n            this.currentTimestamp = time;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n        }\n    }\n    /**\n     * 清除canvas 每次重新绘制需要先清除\n     */\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.canvasW, (this.scale * 7.5));\n    }\n    /**\n     * Click to play\n     */\n    onPlayClick() {\n        // this.setTimeMove = undefined;\n        this.isPlayClick = true;\n        this.setTimeMove = interval(this.speed).subscribe((d) => {\n            this.playTime = Number(this.playTime) + 1 * 1000;\n            this.playClick.emit(this.playTime);\n            this.set_time_to_middle(this.playTime);\n        });\n    }\n    /**\n     * Click on the pause\n     */\n    onPauseClick() {\n        this.isPlayClick = false;\n        if (this.setTimeMove) {\n            // this.setTimeMove = undefined;\n            this.setTimeMove.unsubscribe();\n            this.playClick.emit(this.playTime);\n        }\n    }\n    /**\n     * Change video segment\n     */\n    changeVideo() {\n        const cells = [\n            {\n                beginTime: new Date().getTime() - 1 * 1000 * 3600,\n                endTime: new Date().getTime() + 2 * 1000 * 3600,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.clearCanvas();\n        this.drawPalyBar();\n        this.init(this.startTimestamp, cells, true);\n    }\n    /**\n     * Temporary unused\n     * @param event MatDatepickerInputEvent(Date)\n     */\n    selectedTime(event) {\n        const timestamp = new Date(event.value.getTime());\n        this.set_time_to_middle(Number(timestamp));\n    }\n    /**\n     * Temporary unused\n     * @param event MouseEvent\n     */\n    onDragStart(e) {\n        e.preventDefault();\n        return false;\n    }\n}\nNgxVideoTimelineComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nNgxVideoTimelineComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.2.8\", type: NgxVideoTimelineComponent, selector: \"ngx-video-timeline\", inputs: { canvasHeight: \"canvasHeight\", playTime: \"playTime\", speed: \"speed\", forWardValue: \"forWardValue\", startTimeThreshold: \"startTimeThreshold\", endTimeThreshold: \"endTimeThreshold\", borderColor: \"borderColor\", bgColor: \"bgColor\", bottomLineColor: \"bottomLineColor\", verticalBarColor: \"verticalBarColor\", playBarColor: \"playBarColor\", videoCells: \"videoCells\", isPlayClick: \"isPlayClick\" }, outputs: { playClick: \"playClick\", mouseUp: \"mouseUp\", mouseDown: \"mouseDown\", keyUp: \"keyUp\", keyDown: \"keyDown\" }, host: { listeners: { \"window:resize\": \"onResize()\", \"window:keydown\": \"onKeyDown($event)\", \"window:keyup\": \"onKeyUp($event)\" } }, viewQueries: [{ propertyName: \"canvasExp\", first: true, predicate: [\"timeline\"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"], dependencies: [{ kind: \"directive\", type: i1.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-video-timeline', template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"] }]\n        }], ctorParameters: function () { return []; }, propDecorators: { canvasHeight: [{\n                type: Input\n            }], playTime: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], forWardValue: [{\n                type: Input\n            }], startTimeThreshold: [{\n                type: Input\n            }], endTimeThreshold: [{\n                type: Input\n            }], borderColor: [{\n                type: Input\n            }], bgColor: [{\n                type: Input\n            }], bottomLineColor: [{\n                type: Input\n            }], verticalBarColor: [{\n                type: Input\n            }], playBarColor: [{\n                type: Input\n            }], videoCells: [{\n                type: Input\n            }], isPlayClick: [{\n                type: Input\n            }], playClick: [{\n                type: Output\n            }], mouseUp: [{\n                type: Output\n            }], mouseDown: [{\n                type: Output\n            }], keyUp: [{\n                type: Output\n            }], keyDown: [{\n                type: Output\n            }], canvasExp: [{\n                type: ViewChild,\n                args: ['timeline', { static: true }]\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }], onKeyDown: [{\n                type: HostListener,\n                args: ['window:keydown', ['$event']]\n            }], onKeyUp: [{\n                type: HostListener,\n                args: ['window:keyup', ['$event']]\n            }] } });","originalLength":112052,"removedExports":[],"renderedExports":["DateUtil","NgxVideoTimelineComponent"],"renderedLength":32301},"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/lib/timeline.module.mjs":{"code":"class NgxVideoTimelineModule {\n}\nNgxVideoTimelineModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxVideoTimelineModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, declarations: [NgxVideoTimelineComponent], imports: [CommonModule], exports: [NgxVideoTimelineComponent] });\nNgxVideoTimelineModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, imports: [CommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [NgxVideoTimelineComponent],\n                    imports: [\n                        CommonModule\n                    ],\n                    exports: [NgxVideoTimelineComponent]\n                }]\n        }] });","originalLength":2529,"removedExports":[],"renderedExports":["NgxVideoTimelineModule"],"renderedLength":1062},"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/public-api.mjs":{"code":"/*\n * Public API Surface of timeline\n */","originalLength":628,"removedExports":[],"renderedExports":[],"renderedLength":40},"/Users/mac/lenon/repositories/ngx-video-timeline/dist/timeline/esm2020/ngx-video-timeline.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":512,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Component, Input, Output, ViewChild, HostListener, NgModule } from '@angular/core';\nimport { interval } from 'rxjs';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * A utility class for working with dates.\n */\nclass DateUtil {\n    /**\n     * Formats the given date according to the specified format.\n     * @param date The date to format.\n     * @param format The format string, using the following placeholders:\n     *   - YYYY: four-digit year\n     *   - MM: two-digit month (zero-padded)\n     *   - DD: two-digit day of month (zero-padded)\n     *   - HH: two-digit hour (zero-padded, 24-hour format)\n     *   - mm: two-digit minute (zero-padded)\n     *   - ss: two-digit second (zero-padded)\n     * @returns The formatted date string.\n     */\n    static formatDate(date, format) {\n        // Extract the year, month, day, hours, minutes, and seconds from the date\n        const year = date.getFullYear().toString();\n        const month = (date.getMonth() + 1).toString().padStart(2, '0');\n        const day = date.getDate().toString().padStart(2, '0');\n        const hours = date.getHours().toString().padStart(2, '0');\n        const minutes = date.getMinutes().toString().padStart(2, '0');\n        const seconds = date.getSeconds().toString().padStart(2, '0');\n        // Replace the placeholders in the format string with the corresponding date parts\n        return format\n            .replace('YYYY', year)\n            .replace('MM', month)\n            .replace('DD', day)\n            .replace('HH', hours)\n            .replace('mm', minutes)\n            .replace('ss', seconds);\n    }\n}\nclass NgxVideoTimelineComponent {\n    constructor() {\n        // The height of the outer canvas\n        this.canvasHeight = 50;\n        // Canvas scale is adjusted according to outer height\n        this.scale = this.canvasHeight / 4.55;\n        // The position of the X-axis when the mouse is pressed\n        this.gMousedownCursor = undefined;\n        // The position of the y-axis when the mouse is pressed\n        this.gMousedownCursorY = undefined;\n        // this.startTimeThreshold = new Date().getTime() - 1 * 0.5 * 3600 * 1000;\n        // this.endTimeThreshold = new Date().getTime() + 1 * 1 * 3600 * 1000;\n        this.forWardValue = 5000;\n        this.speed = 1000;\n        this.playTime = new Date().getTime();\n        this.startTimeThreshold = new Date().getTime() - 1 * 12 * 3600 * 1000;\n        this.endTimeThreshold = new Date().getTime() + 1 * 12 * 3600 * 1000;\n        this.playClick = new EventEmitter();\n        this.mouseUp = new EventEmitter();\n        this.mouseDown = new EventEmitter();\n        this.keyUp = new EventEmitter();\n        this.keyDown = new EventEmitter();\n        this.isPlayClick = false;\n        this.videoCells = [\n            {\n                beginTime: new Date().getTime() - 3 * 3600 * 1000,\n                endTime: new Date().getTime() - 1 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            },\n            {\n                beginTime: new Date().getTime() - 6 * 3600 * 1000,\n                endTime: new Date().getTime() - 4 * 3600 * 1000,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.verticalBarColor = 'rgba(0,0,0,1)';\n        this.bottomLineColor = 'rgba(0,0,0,1)';\n        this.borderColor = '#fff';\n        this.bgColor = '#fff';\n        this.playBarColor = '#448aff';\n    }\n    /**\n     * Browser change event\n     */\n    onResize() {\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        this.canvasW = this.canvas.parentNode.offsetWidth;\n        this.init(this.startTimestamp, this.timecell, false);\n    }\n    /**\n     * Keyboard press event\n     */\n    onKeyDown(event) {\n        if (Number(event.keyCode) === 37) {\n            this.playTime = Number(this.playTime) - this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) - this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        else if (Number(event.keyCode === 39)) {\n            this.playTime = Number(this.playTime) + this.forWardValue;\n            this.currentTimestamp = Number(this.currentTimestamp) + this.forWardValue;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.keyDown.emit(this.playTime);\n    }\n    /**\n     * Keyboard release event\n     */\n    onKeyUp(event) {\n        if (Number(event.keyCode) === 13 || Number(event.keyCode === 32)) {\n            this.isPlayClick ? this.onPauseClick() : this.onPlayClick();\n        }\n        this.keyUp.emit(this.playTime);\n    }\n    ngOnInit() {\n        // Initialize data video group event stamp to show new Date().getTime()- number of hours\n        // Assign the Canvas DOM to the variable Canvas\n        this.canvas = this.canvasExp.nativeElement;\n        // Define the area of the canvas\n        this.ctx = this.canvas.getContext('2d');\n        // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n        // Store the width and height of the canvas\n        this.canvasW = this.canvas.width;\n        this.canvas.height = this.canvasHeight;\n        this.canvasH = this.canvas.height;\n        // Assign the video array to Timecell\n        this.timecell = this.videoCells;\n        // Initialize the number of steps per minute\n        this.minutesPerStep = [\n            1,\n            2,\n            5,\n            10,\n            15,\n            20,\n            30,\n            60,\n            120,\n            180,\n            240,\n            360,\n            720,\n            1440\n        ];\n        // Initialization style\n        // Minimum width between scales, in units of px 20px\n        this.graduationStep = 20;\n        // The timeline shows the time rounded up according to the time threshold\n        this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n            Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) :\n            24;\n        // The leftmost timestamp defaults to 12 hours before the current time\n        this.startTimestamp = Number(this.startTimeThreshold);\n        // Default distance 80\n        this.distanceBetweenGtitle = 80;\n        // Default zoom 24\n        this.zoom = 24;\n        // Default false\n        this.gIsMousedown = false;\n        this.gIsMousemove = false;\n        this.gMousedownCursor = undefined;\n        // px/ms\n        this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        // The initial X position of the playback icon is in the middle of the scale\n        this.playBarOffsetX = this.canvasW / 2;\n        this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n        this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n        this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n        this.playBarOffsetY1 = (this.scale * 2.5);\n        this.playBarOffsetY2 = ((this.scale * 3.5));\n        // Initialize the timeline\n        this.init(this.startTimestamp, this.timecell, false);\n        // Draw the play button\n        this.drawPalyBar();\n    }\n    ngOnChanges(changes) {\n        // Refactor the playback component when the width and height change\n        if (changes.canvasHeight) {\n            this.canvasHeight = changes.canvasHeight.currentValue;\n            // Assign the Canvas DOM to the variable Canvas\n            this.canvas = this.canvasExp.nativeElement;\n            // Define the area of the canvas\n            this.ctx = this.canvas.getContext('2d');\n            // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\n            this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\n            // Store the width and height of the canvas\n            this.canvasW = this.canvas.width;\n            this.canvas.height = this.canvasHeight;\n            this.canvasH = this.canvas.height;\n            // Assign the video array to Timecell\n            this.timecell = this.videoCells;\n            this.minutesPerStep = [\n                1,\n                2,\n                5,\n                10,\n                15,\n                20,\n                30,\n                60,\n                120,\n                180,\n                240,\n                360,\n                720,\n                1440\n            ];\n            // The timeline shows the time rounded up according to the time threshold\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\n                Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            // The leftmost timestamp defaults to 12 hours before the current time\n            this.startTimestamp = Number(this.startTimeThreshold);\n            this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n            // The initial X position of the playback icon is in the middle of the scale\n            this.playBarOffsetX = this.canvasW / 2;\n            this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n            // Current timestamp\n            this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n            this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n            this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n            this.playBarOffsetY1 = (this.scale * 2.5);\n            this.playBarOffsetY2 = ((this.scale * 3.5));\n            this.init(this.startTimestamp, this.timecell, false);\n            this.drawPalyBar();\n        }\n        if (changes.videoCells) {\n            this.videoCells = changes.videoCells.currentValue;\n            this.timecell = this.videoCells;\n            this.add_cells(this.timecell);\n            // this.init(this.startTimestamp, this.timecell, true);\n            // this.drawPalyBar();\n        }\n        if (changes.startTimeThreshold) {\n            const value = changes.startTimeThreshold.currentValue;\n            if (changes.startTimeThreshold.currentValue instanceof String) {\n                this.startTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.startTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.startTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n            this.startTimestamp = Number(this.startTimeThreshold);\n            // this.init(this.startTimestamp, this.timecell, false);\n        }\n        if (changes.endTimeThreshold) {\n            const value = changes.endTimeThreshold.currentValue;\n            if (changes.endTimeThreshold.currentValue instanceof String) {\n                this.endTimeThreshold = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.endTimeThreshold = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.endTimeThreshold = Number(value);\n            }\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\n                : 24;\n        }\n        if (changes.playTime) {\n            const value = changes.playTime.currentValue;\n            if (changes.playTime.currentValue instanceof String) {\n                this.playTime = new Date(value).getTime();\n            }\n            else if (value instanceof Date) {\n                this.playTime = value.getTime();\n            }\n            else if (typeof value === 'number') {\n                this.playTime = Number(value);\n            }\n            // use SetTimeOut Timer to make it  asynchronous\n            setTimeout(() => {\n                this.set_time_to_middle(new Date(this.playTime).getTime());\n            }, 100);\n        }\n        if (changes.speed) {\n            this.speed = Number(changes.speed.currentValue) * 1000;\n        }\n        if (changes.forWardValue) {\n            this.forWardValue = Number(changes.forWardValue.currentValue) * 1000;\n        }\n        if (changes.isPlayClick) {\n            if (changes.isPlayClick.currentValue) {\n                this.onPlayClick();\n            }\n            else {\n                this.onPauseClick();\n            }\n        }\n    }\n    /**\n     * Initialize\n     * @param  startTimestamp Leftmost time\n     * @param  timecell Video segment array\n     * @param  redrawFlag Whether to redraw the mark\n     */\n    init(startTimestamp, timecell, redrawFlag) {\n        this.timecell = timecell;\n        this.startTimestamp = startTimestamp;\n        if (this.currentTimestamp >=\n            this.endTimeThreshold) {\n            this.startTimestamp =\n                Number(this.endTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        else if (this.currentTimestamp <=\n            this.startTimeThreshold) {\n            this.startTimestamp =\n                Number(this.startTimeThreshold) -\n                    (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.currentTimestamp =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n            this.playTime =\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\n        }\n        this.drawCellBg();\n        this.add_graduations(startTimestamp);\n        this.add_cells(timecell);\n        // Draw the verticalBar\n        this.drawLine(0, this.canvasH, this.canvasW, this.canvasH, this.bottomLineColor, 1);\n    }\n    /**\n     * Draw add scale\n     * @param  startTimestamp Leftmost time\n     */\n    add_graduations(startTimestamp) {\n        // px/min\n        const pxPerMin = this.canvasW / (this.hoursPerRuler * 60);\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000);\n        // The default minimum value of PX/steo is 20px\n        let pxPerStep = this.graduationStep;\n        // Min/steo\n        let minPerStep = pxPerStep / pxPerMin;\n        for (const v of this.minutesPerStep) {\n            if (minPerStep <= v) {\n                // Keep each cell within the range specified by minutesPerStep\n                minPerStep = v;\n                pxPerStep = pxPerMin * minPerStep;\n                break;\n            }\n        }\n        let mediumStep = 30;\n        for (const v of this.minutesPerStep) {\n            if (this.distanceBetweenGtitle / pxPerMin <= v) {\n                mediumStep = v;\n                break;\n            }\n        }\n        // The total number\n        const numSteps = this.canvasW / pxPerStep;\n        let graduationLeft;\n        let graduationTime;\n        let caretClass;\n        let lineH;\n        // The initial offset time (ms)\n        const msOffset = this.ms_to_next_step(startTimestamp, minPerStep * 60 * 1000);\n        // The initial offset is (px)\n        const pxOffset = msOffset * pxPerMs;\n        // ms/step\n        const msPerStep = pxPerStep / pxPerMs;\n        for (let i = 0; i < numSteps; i++) {\n            // Distance = offset distance to start + steps *px/ steps\n            graduationLeft = pxOffset + i * pxPerStep;\n            // Time = left start time + offset time + steps *ms/ steps\n            graduationTime =\n                Number(startTimestamp) +\n                    Number(msOffset) +\n                    i * Number(msPerStep);\n            const date = new Date(graduationTime);\n            if (date.getUTCHours() === 0 && date.getUTCMinutes() === 0) {\n                caretClass = 'big';\n                lineH = (this.scale * 1.25);\n                const bigDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(bigDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else if ((graduationTime / (60 * 1000)) % mediumStep === 0) {\n                caretClass = 'middle';\n                lineH = (this.scale * 0.75);\n                const middleDate = DateUtil.formatDate(date, 'HH:mm:ss');\n                this.ctx.textAlign = 'center';\n                this.ctx.fillText(middleDate, graduationLeft, (this.scale * 1.5));\n                this.ctx.fillStyle = this.verticalBarColor;\n            }\n            else {\n                lineH = (this.scale * 0.5);\n            }\n            // drawLine(graduationLeft,0,graduationLeft,lineH,\"rgba(151,158,167,0.4)\",1);\n            this.drawLine(graduationLeft, 0, graduationLeft, lineH, this.verticalBarColor, 1);\n        }\n    }\n    /**\n     * Draw the play button\n     */\n    drawPalyBar() {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.playBarOffsetX, 0);\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.strokeStyle = this.playBarColor;\n        this.ctx.stroke();\n        this.ctx.moveTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 3.5));\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 2.5));\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.fill();\n        this.ctx.closePath();\n        // this.init(this.startTimestamp, this.timecell, false);\n        const time = Number(this.currentTimestamp);\n        this.ctx.fillStyle = this.playBarColor;\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), this.playBarOffsetX, (this.scale * 4.25));\n    }\n    /**\n     * Draw the line\n     * @param  beginX The X-axis to start with\n     * @param  beginY The Y-axis to start with\n     * @param  endX The end of the X-axis\n     * @param  endY The end of the Y-axis\n     * @param  color color\n     * @param  width width\n     */\n    drawLine(beginX, beginY, endX, endY, color, width) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(beginX, beginY);\n        this.ctx.lineTo(endX, endY);\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = width;\n        this.ctx.stroke();\n    }\n    /**\n     * Add video segment\n     * @param  cells Video array\n     */\n    add_cells(cells) {\n        cells.forEach((cell) => {\n            this.draw_cell(cell);\n        });\n    }\n    /**\n     * Draw video blocks\n     * @param  cell The cell includes beginTime Ms; The endTime ms; style;\n     */\n    draw_cell(cell) {\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000); // px/ms\n        const beginX = (cell.beginTime - this.startTimestamp) * pxPerMs;\n        const cellWidth = (cell.endTime - cell.beginTime) * pxPerMs;\n        this.ctx.fillStyle = cell.style.background;\n        this.ctx.fillRect(beginX, 0, cellWidth, (this.scale * 0.75));\n    }\n    /**\n     * Draws the background of the video block\n     */\n    drawCellBg() {\n        this.ctx.fillStyle = 'rgba(69, 72, 76, 0.5)';\n        this.ctx.fillRect(0, 0, this.canvasW, 0);\n    }\n    /**\n     * Drag/click the Mousedown event\n     */\n    mousedownFunc(e) {\n        this.gIsMousedown = true;\n        this.gMousedownCursor = this.get_cursor_x_position(e).posX;\n        this.gMousedownCursorY = this.get_cursor_x_position(e).posY;\n    }\n    /**\n     * Drag/mouse hover to display mousemove events\n     */\n    mousemoveFunc(e) {\n        this.clearCanvas();\n        const posX = this.get_cursor_x_position(e).posX;\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        const diffX = posX - this.gMousedownCursor;\n        if (this.gIsMousedown) {\n            if (this.gMousedownCursor >= this.playBarOffsetX1 &&\n                this.gMousedownCursor <= this.playBarOffsetX2 &&\n                this.gMousedownCursorY >= this.playBarOffsetY1 &&\n                this.gMousedownCursorY <= this.playBarOffsetY2) {\n                // this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\n                // this.playBarOffsetX = posX;\n                // this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\n                // this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\n                this.startTimestamp =\n                    this.startTimestamp + Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    (this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs));\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, false);\n                this.gIsMousemove = true;\n            }\n            else {\n                this.startTimestamp =\n                    this.startTimestamp - Math.round(diffX / pxPerMs);\n                this.currentTimestamp =\n                    this.startTimestamp +\n                        Math.round(this.playBarOffsetX / pxPerMs);\n                this.drawPalyBar();\n                this.init(this.startTimestamp, this.timecell, true);\n                this.gIsMousemove = true;\n                this.gMousedownCursor = posX;\n            }\n            this.mouseUp.emit(this.currentTimestamp);\n        }\n        else {\n            const time = this.startTimestamp + posX / pxPerMs;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n            this.drawLine(posX, 0, posX, 50, 'rgb(194, 202, 215)', 1);\n            this.ctx.fillStyle = 'rgb(194, 202, 215)';\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText(DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'), posX, (this.scale * 3));\n        }\n    }\n    /**\n     * Drag/click the Mouseup event\n     */\n    mouseupFunc(e) {\n        if (this.gIsMousemove) {\n            // Drag events\n            this.gIsMousemove = false;\n            this.gIsMousedown = false;\n            this.playTime =\n                this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\n        }\n        else {\n            // Click event\n            this.gIsMousedown = false;\n            // Mouse distance (px)\n            const posx = this.get_cursor_x_position(e).posX;\n            // ms/px\n            const msPerPx = (this.zoom * 3600 * 1000) / this.canvasW;\n            this.playTime = this.startTimestamp + posx * msPerPx;\n            this.set_time_to_middle(this.playTime);\n        }\n        this.mouseDown.emit(this.playTime);\n    }\n    /**\n     * Mouseout of the hidden time mouseout event\n     */\n    mouseoutFunc() {\n        this.clearCanvas();\n        // px/ms\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\n        this.currentTimestamp =\n            this.startTimestamp +\n                Math.round(this.playBarOffsetX / pxPerMs);\n        this.drawPalyBar();\n        this.init(this.startTimestamp, this.timecell, true);\n    }\n    /**\n     * Scroll to the center of the timeline for the mousewheel event\n     */\n    mousewheelFunc(event) {\n        if (event && event.preventDefault) {\n            event.preventDefault();\n        }\n        else {\n            window.event.returnValue = false;\n            return false;\n        }\n        const e = window.event || event;\n        const delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));\n        // Ms Remember the current middle time\n        const middleTime = this.startTimestamp + (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n        if (delta < 0) {\n            this.zoom = this.zoom + 4;\n            if (this.zoom >= 24) {\n                // Shrink to a minimum of 24 hours\n                this.zoom = 24;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        else if (delta > 0) {\n            // amplification\n            this.zoom = this.zoom - 4;\n            if (this.zoom <= 1) {\n                // Zoom in at most one hour\n                this.zoom = 1;\n            }\n            this.hoursPerRuler = this.zoom;\n        }\n        this.clearCanvas();\n        // // startTimestamp = current middle time - zoom /2\n        this.startTimestamp =\n            middleTime - (this.hoursPerRuler * 3600 * 1000) / 2;\n        this.init(this.startTimestamp, this.timecell, true);\n        this.drawPalyBar();\n    }\n    /**\n     * Get the mouse POSx\n     * @param  e event\n     */\n    get_cursor_x_position(e) {\n        let posx = 0;\n        let posy = 0;\n        if (!e) {\n            e = window.event;\n        }\n        if (e.offsetX || e.offsetY) {\n            posx = e.offsetX;\n            posy = e.offsetY;\n        }\n        return { posX: posx, posY: posy };\n    }\n    /**\n     * The offset of the left start time, returns the unit ms\n     * @param  timestamp The time stamp\n     * @param  step The offset\n     */\n    ms_to_next_step(timestamp, step) {\n        const remainder = timestamp % step;\n        return remainder ? step - remainder : 0;\n    }\n    /**\n     * Set the time to jump to the middle red line\n     *  @param  time Unit of ms\n     */\n    set_time_to_middle(time) {\n        if (this.ctx) {\n            this.clearCanvas();\n            this.startTimestamp = time - (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\n            this.currentTimestamp = time;\n            this.drawPalyBar();\n            this.init(this.startTimestamp, this.timecell, true);\n        }\n    }\n    /**\n     * 清除canvas 每次重新绘制需要先清除\n     */\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.canvasW, (this.scale * 7.5));\n    }\n    /**\n     * Click to play\n     */\n    onPlayClick() {\n        // this.setTimeMove = undefined;\n        this.isPlayClick = true;\n        this.setTimeMove = interval(this.speed).subscribe((d) => {\n            this.playTime = Number(this.playTime) + 1 * 1000;\n            this.playClick.emit(this.playTime);\n            this.set_time_to_middle(this.playTime);\n        });\n    }\n    /**\n     * Click on the pause\n     */\n    onPauseClick() {\n        this.isPlayClick = false;\n        if (this.setTimeMove) {\n            // this.setTimeMove = undefined;\n            this.setTimeMove.unsubscribe();\n            this.playClick.emit(this.playTime);\n        }\n    }\n    /**\n     * Change video segment\n     */\n    changeVideo() {\n        const cells = [\n            {\n                beginTime: new Date().getTime() - 1 * 1000 * 3600,\n                endTime: new Date().getTime() + 2 * 1000 * 3600,\n                style: {\n                    background: 'rgba(132, 244, 180, 0.498039)'\n                }\n            }\n        ];\n        this.clearCanvas();\n        this.drawPalyBar();\n        this.init(this.startTimestamp, cells, true);\n    }\n    /**\n     * Temporary unused\n     * @param event MatDatepickerInputEvent(Date)\n     */\n    selectedTime(event) {\n        const timestamp = new Date(event.value.getTime());\n        this.set_time_to_middle(Number(timestamp));\n    }\n    /**\n     * Temporary unused\n     * @param event MouseEvent\n     */\n    onDragStart(e) {\n        e.preventDefault();\n        return false;\n    }\n}\nNgxVideoTimelineComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nNgxVideoTimelineComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"15.2.8\", type: NgxVideoTimelineComponent, selector: \"ngx-video-timeline\", inputs: { canvasHeight: \"canvasHeight\", playTime: \"playTime\", speed: \"speed\", forWardValue: \"forWardValue\", startTimeThreshold: \"startTimeThreshold\", endTimeThreshold: \"endTimeThreshold\", borderColor: \"borderColor\", bgColor: \"bgColor\", bottomLineColor: \"bottomLineColor\", verticalBarColor: \"verticalBarColor\", playBarColor: \"playBarColor\", videoCells: \"videoCells\", isPlayClick: \"isPlayClick\" }, outputs: { playClick: \"playClick\", mouseUp: \"mouseUp\", mouseDown: \"mouseDown\", keyUp: \"keyUp\", keyDown: \"keyDown\" }, host: { listeners: { \"window:resize\": \"onResize()\", \"window:keydown\": \"onKeyDown($event)\", \"window:keyup\": \"onKeyUp($event)\" } }, viewQueries: [{ propertyName: \"canvasExp\", first: true, predicate: [\"timeline\"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"], dependencies: [{ kind: \"directive\", type: i1.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-video-timeline', template: \"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\", styles: [\".canvas{width:100%;height:100%}\\n\"] }]\n        }], ctorParameters: function () { return []; }, propDecorators: { canvasHeight: [{\n                type: Input\n            }], playTime: [{\n                type: Input\n            }], speed: [{\n                type: Input\n            }], forWardValue: [{\n                type: Input\n            }], startTimeThreshold: [{\n                type: Input\n            }], endTimeThreshold: [{\n                type: Input\n            }], borderColor: [{\n                type: Input\n            }], bgColor: [{\n                type: Input\n            }], bottomLineColor: [{\n                type: Input\n            }], verticalBarColor: [{\n                type: Input\n            }], playBarColor: [{\n                type: Input\n            }], videoCells: [{\n                type: Input\n            }], isPlayClick: [{\n                type: Input\n            }], playClick: [{\n                type: Output\n            }], mouseUp: [{\n                type: Output\n            }], mouseDown: [{\n                type: Output\n            }], keyUp: [{\n                type: Output\n            }], keyDown: [{\n                type: Output\n            }], canvasExp: [{\n                type: ViewChild,\n                args: ['timeline', { static: true }]\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }], onKeyDown: [{\n                type: HostListener,\n                args: ['window:keydown', ['$event']]\n            }], onKeyUp: [{\n                type: HostListener,\n                args: ['window:keyup', ['$event']]\n            }] } });\n\nclass NgxVideoTimelineModule {\n}\nNgxVideoTimelineModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxVideoTimelineModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, declarations: [NgxVideoTimelineComponent], imports: [CommonModule], exports: [NgxVideoTimelineComponent] });\nNgxVideoTimelineModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, imports: [CommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.2.8\", ngImport: i0, type: NgxVideoTimelineModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [NgxVideoTimelineComponent],\n                    imports: [\n                        CommonModule\n                    ],\n                    exports: [NgxVideoTimelineComponent]\n                }]\n        }] });\n\n/*\n * Public API Surface of timeline\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DateUtil, NgxVideoTimelineComponent, NgxVideoTimelineModule };\n//# sourceMappingURL=ngx-video-timeline.mjs.map\n","map":null},{"fileName":"ngx-video-timeline.mjs.map","needsCodeReference":false,"source":"{\"version\":3,\"file\":\"ngx-video-timeline.mjs\",\"sources\":[\"../../../projects/timeline/src/lib/timeline.component.ts\",\"../../../projects/timeline/src/lib/timeline.component.html\",\"../../../projects/timeline/src/lib/timeline.module.ts\",\"../../../projects/timeline/src/public-api.ts\",\"../../../projects/timeline/src/ngx-video-timeline.ts\"],\"sourcesContent\":[\"import {\\n    Component,\\n    ElementRef,\\n    EventEmitter,\\n    HostListener,\\n    Input,\\n    OnChanges,\\n    OnInit,\\n    Output, SimpleChanges,\\n    ViewChild\\n} from '@angular/core';\\nimport { interval, Subscription } from 'rxjs';\\n\\n/**\\n * A utility class for working with dates.\\n */\\nexport class DateUtil {\\n\\n  /**\\n   * Formats the given date according to the specified format.\\n   * @param date The date to format.\\n   * @param format The format string, using the following placeholders:\\n   *   - YYYY: four-digit year\\n   *   - MM: two-digit month (zero-padded)\\n   *   - DD: two-digit day of month (zero-padded)\\n   *   - HH: two-digit hour (zero-padded, 24-hour format)\\n   *   - mm: two-digit minute (zero-padded)\\n   *   - ss: two-digit second (zero-padded)\\n   * @returns The formatted date string.\\n   */\\n  static formatDate(date: Date, format: string): string {\\n    // Extract the year, month, day, hours, minutes, and seconds from the date\\n    const year = date.getFullYear().toString();\\n    const month = (date.getMonth() + 1).toString().padStart(2, '0');\\n    const day = date.getDate().toString().padStart(2, '0');\\n    const hours = date.getHours().toString().padStart(2, '0');\\n    const minutes = date.getMinutes().toString().padStart(2, '0');\\n    const seconds = date.getSeconds().toString().padStart(2, '0');\\n\\n    // Replace the placeholders in the format string with the corresponding date parts\\n    return format\\n      .replace('YYYY', year)\\n      .replace('MM', month)\\n      .replace('DD', day)\\n      .replace('HH', hours)\\n      .replace('mm', minutes)\\n      .replace('ss', seconds);\\n  }\\n}\\nexport interface CanvasPos {\\n    posX: number;\\n    posY: number;\\n}\\n\\nexport interface VideoCellStyleType {\\n    background: string;\\n}\\n\\nexport interface VideoCellType {\\n    beginTime: number | string;\\n    endTime: number | string;\\n    style?: VideoCellStyleType;\\n}\\n\\n\\n@Component({\\n    selector: 'ngx-video-timeline',\\n    templateUrl: './timeline.component.html',\\n    styleUrls: ['./timeline.component.scss']\\n})\\nexport class NgxVideoTimelineComponent implements OnInit, OnChanges {\\n\\n\\n    // The height of the outer canvas\\n    @Input() canvasHeight = 50;\\n\\n    // Canvas scale is adjusted according to outer height\\n    scale = this.canvasHeight / 4.55;\\n\\n    // Video playback time\\n    @Input() playTime: number | string | Date;\\n\\n    // The video plays at twice the speed\\n    @Input() speed: number;\\n\\n    // Video fast forward value\\n    @Input() forWardValue: number;\\n\\n    // Start time limit: Timestamp\\n    @Input() startTimeThreshold: number | string | Date;\\n\\n    // End time limit: Timestamp\\n    @Input() endTimeThreshold: number | string | Date;\\n\\n    // relation to Css Start\\n\\n    // color of canvas border\\n    @Input() borderColor: string;\\n\\n    // color of canvas backgraound\\n    @Input() bgColor: string;\\n\\n    // color of the bottomLine\\n    @Input() bottomLineColor: string;\\n\\n    // color of the verticalBar\\n    @Input() verticalBarColor: string;\\n\\n    // color of the playBar\\n    @Input() playBarColor: string;\\n\\n\\n    // relation to Css End\\n\\n    // Video clips\\n    @Input() videoCells: Array<VideoCellType>;\\n\\n    // flag of click play button\\n    @Input() isPlayClick: boolean;\\n\\n    // emit data when click playButton\\n    @Output() readonly playClick: EventEmitter<any>;\\n\\n    // emit data when mouseUp\\n    @Output() readonly mouseUp: EventEmitter<any>;\\n\\n    // emit data when mouseDown\\n    @Output() readonly mouseDown: EventEmitter<any>;\\n\\n    // emit data when keyUp\\n    @Output() readonly keyUp: EventEmitter<any>;\\n\\n    // emit data when keyDown\\n    @Output() readonly keyDown: EventEmitter<any>;\\n\\n    // --- canvas data start ---//\\n\\n    // canvas box\\n    canvas: any;\\n\\n    // canvas context\\n    ctx: any;\\n\\n    // canvas width\\n    canvasW: number;\\n\\n    // canvas height\\n    canvasH: number;\\n\\n    // video clips in reality\\n    timecell: Array<VideoCellType>;\\n\\n    // per minute stand for step\\n    minutesPerStep: Array<number>;\\n\\n    // per minite stand for px\\n    pxPerMs: number;\\n\\n    // Minimum width between scales, unit px\\n    graduationStep: number;\\n\\n    // The timeline shows x hours\\n    hoursPerRuler: number;\\n\\n    // The leftmost timestamp that appears -- the default is the first 12 hours\\n    startTimestamp: number;\\n\\n    // current timestamp\\n    currentTimestamp: number;\\n\\n    // Px two hours apart\\n    distanceBetweenGtitle: number;\\n\\n    // zoom of canvas\\n    zoom: number;\\n\\n    // marker of drag an unreleased mouse event\\n    gIsMousedown: boolean;\\n\\n    // marker of drag the mouse move\\n    gIsMousemove: boolean;\\n\\n    // The position of the X-axis when the mouse is pressed\\n    gMousedownCursor = undefined;\\n\\n    // The position of the y-axis when the mouse is pressed\\n    gMousedownCursorY = undefined;\\n\\n    // Time flow timer\\n    setTimeMove: Subscription;\\n\\n    // The distance to the left of the play button\\n    playBarDistanceLeft: number;\\n\\n    // Play the initial position of the icon\\n    playBarOffsetX: number;\\n\\n    // Play the X-axis position 1 of the icon\\n    playBarOffsetX1: number;\\n\\n    // Play the X-axis position 2 of the icon\\n    playBarOffsetX2: number;\\n\\n    // Play the Y-axis position 1 of the icon\\n    playBarOffsetY1: number;\\n\\n    // Play the Y-axis position 2 of the icon\\n    playBarOffsetY2: number;\\n\\n    // --- canvas data end ---//\\n\\n    // elements of the timeline\\n    @ViewChild('timeline', { static: true }) canvasExp: ElementRef;\\n\\n    constructor() {\\n        // this.startTimeThreshold = new Date().getTime() - 1 * 0.5 * 3600 * 1000;\\n        // this.endTimeThreshold = new Date().getTime() + 1 * 1 * 3600 * 1000;\\n        this.forWardValue = 5000;\\n        this.speed = 1000;\\n        this.playTime = new Date().getTime();\\n        this.startTimeThreshold = new Date().getTime() - 1 * 12 * 3600 * 1000;\\n        this.endTimeThreshold = new Date().getTime() + 1 * 12 * 3600 * 1000;\\n        this.playClick = new EventEmitter<any>();\\n        this.mouseUp = new EventEmitter<any>();\\n        this.mouseDown = new EventEmitter<any>();\\n        this.keyUp = new EventEmitter<any>();\\n        this.keyDown = new EventEmitter<any>();\\n        this.isPlayClick = false;\\n        this.videoCells = [\\n            {\\n                beginTime: new Date().getTime() - 3 * 3600 * 1000,\\n                endTime: new Date().getTime() - 1 * 3600 * 1000,\\n                style: {\\n                    background: 'rgba(132, 244, 180, 0.498039)'\\n                }\\n            },\\n            {\\n                beginTime: new Date().getTime() - 6 * 3600 * 1000,\\n                endTime: new Date().getTime() - 4 * 3600 * 1000,\\n                style: {\\n                    background: 'rgba(132, 244, 180, 0.498039)'\\n                }\\n            }\\n        ];\\n        this.verticalBarColor = 'rgba(0,0,0,1)';\\n        this.bottomLineColor = 'rgba(0,0,0,1)';\\n        this.borderColor = '#fff';\\n        this.bgColor = '#fff';\\n        this.playBarColor = '#448aff';\\n    }\\n\\n    /**\\n     * Browser change event\\n     */\\n    @HostListener('window:resize', [])\\n    onResize(): void {\\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\\n        this.canvasW = this.canvas.parentNode.offsetWidth;\\n        this.init(this.startTimestamp, this.timecell, false);\\n    }\\n\\n    /**\\n     * Keyboard press event\\n     */\\n    @HostListener('window:keydown', ['$event'])\\n    onKeyDown(event: any): void {\\n        if (Number(event.keyCode) === 37) {\\n            this.playTime = Number(this.playTime) - this.forWardValue;\\n            this.currentTimestamp = Number(this.currentTimestamp) - this.forWardValue;\\n            this.set_time_to_middle(this.playTime);\\n\\n        } else if (Number(event.keyCode === 39)) {\\n            this.playTime = Number(this.playTime) + this.forWardValue;\\n            this.currentTimestamp = Number(this.currentTimestamp) + this.forWardValue;\\n            this.set_time_to_middle(this.playTime);\\n        }\\n        this.keyDown.emit(this.playTime);\\n    }\\n\\n    /**\\n     * Keyboard release event\\n     */\\n    @HostListener('window:keyup', ['$event'])\\n    onKeyUp(event: any): void {\\n        if (Number(event.keyCode) === 13 || Number(event.keyCode === 32)) {\\n            this.isPlayClick ? this.onPauseClick() : this.onPlayClick();\\n        }\\n        this.keyUp.emit(this.playTime);\\n    }\\n\\n    ngOnInit(): void {\\n        // Initialize data video group event stamp to show new Date().getTime()- number of hours\\n\\n        // Assign the Canvas DOM to the variable Canvas\\n        this.canvas = this.canvasExp.nativeElement;\\n\\n        // Define the area of the canvas\\n        this.ctx = this.canvas.getContext('2d');\\n\\n        // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\\n        this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\\n\\n        // Store the width and height of the canvas\\n        this.canvasW = this.canvas.width;\\n        this.canvas.height = this.canvasHeight;\\n        this.canvasH = this.canvas.height;\\n\\n        // Assign the video array to Timecell\\n        this.timecell = this.videoCells;\\n\\n        // Initialize the number of steps per minute\\n        this.minutesPerStep = [\\n            1,\\n            2,\\n            5,\\n            10,\\n            15,\\n            20,\\n            30,\\n            60,\\n            120,\\n            180,\\n            240,\\n            360,\\n            720,\\n            1440\\n        ];\\n\\n        // Initialization style\\n\\n        // Minimum width between scales, in units of px 20px\\n        this.graduationStep = 20;\\n\\n        // The timeline shows the time rounded up according to the time threshold\\n        this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\\n            Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) :\\n            24;\\n\\n        // The leftmost timestamp defaults to 12 hours before the current time\\n        this.startTimestamp = Number(this.startTimeThreshold);\\n\\n        // Default distance 80\\n        this.distanceBetweenGtitle = 80;\\n        // Default zoom 24\\n        this.zoom = 24;\\n\\n        // Default false\\n        this.gIsMousedown = false;\\n        this.gIsMousemove = false;\\n        this.gMousedownCursor = undefined;\\n\\n        // px/ms\\n        this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\\n\\n        // The initial X position of the playback icon is in the middle of the scale\\n        this.playBarOffsetX = this.canvasW / 2;\\n\\n        this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\\n        this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\\n\\n        this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\\n        this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\\n        this.playBarOffsetY1 = (this.scale * 2.5);\\n        this.playBarOffsetY2 = ((this.scale * 3.5));\\n\\n        // Initialize the timeline\\n        this.init(this.startTimestamp, this.timecell, false);\\n\\n        // Draw the play button\\n        this.drawPalyBar();\\n    }\\n\\n    ngOnChanges(changes: SimpleChanges): void {\\n        // Refactor the playback component when the width and height change\\n        if (changes.canvasHeight) {\\n            this.canvasHeight = changes.canvasHeight.currentValue;\\n\\n            // Assign the Canvas DOM to the variable Canvas\\n            this.canvas = this.canvasExp.nativeElement;\\n\\n            // Define the area of the canvas\\n            this.ctx = this.canvas.getContext('2d');\\n\\n            // Redefine the width of the canvas. The default canvas is 300. Assign the width of the parent element\\n            this.canvas.width = Math.round(this.canvas.parentNode.offsetWidth - 2);\\n\\n            // Store the width and height of the canvas\\n            this.canvasW = this.canvas.width;\\n\\n            this.canvas.height = this.canvasHeight;\\n            this.canvasH = this.canvas.height;\\n\\n            // Assign the video array to Timecell\\n            this.timecell = this.videoCells;\\n\\n            this.minutesPerStep = [\\n                1,\\n                2,\\n                5,\\n                10,\\n                15,\\n                20,\\n                30,\\n                60,\\n                120,\\n                180,\\n                240,\\n                360,\\n                720,\\n                1440\\n            ];\\n            // The timeline shows the time rounded up according to the time threshold\\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24 ?\\n                Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\\n                : 24;\\n\\n            // The leftmost timestamp defaults to 12 hours before the current time\\n            this.startTimestamp = Number(this.startTimeThreshold);\\n\\n            this.pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\\n\\n            // The initial X position of the playback icon is in the middle of the scale\\n            this.playBarOffsetX = this.canvasW / 2;\\n\\n            this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\\n            // Current timestamp\\n            this.currentTimestamp = this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\\n\\n            this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\\n            this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\\n            this.playBarOffsetY1 = (this.scale * 2.5);\\n            this.playBarOffsetY2 = ((this.scale * 3.5));\\n\\n            this.init(this.startTimestamp, this.timecell, false);\\n            this.drawPalyBar();\\n        }\\n        if (changes.videoCells) {\\n            this.videoCells = changes.videoCells.currentValue;\\n\\n            this.timecell = this.videoCells;\\n            this.add_cells(this.timecell);\\n\\n            // this.init(this.startTimestamp, this.timecell, true);\\n            // this.drawPalyBar();\\n        }\\n        if (changes.startTimeThreshold) {\\n            const value = changes.startTimeThreshold.currentValue;\\n            if (changes.startTimeThreshold.currentValue instanceof String) {\\n                this.startTimeThreshold = new Date(value).getTime();\\n            } else if (value instanceof Date) {\\n                this.startTimeThreshold = value.getTime();\\n            } else if (typeof value === 'number') {\\n                this.startTimeThreshold = Number(value);\\n            }\\n\\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\\n                : 24;\\n\\n            this.startTimestamp = Number(this.startTimeThreshold);\\n            // this.init(this.startTimestamp, this.timecell, false);\\n        }\\n        if (changes.endTimeThreshold) {\\n            const value = changes.endTimeThreshold.currentValue;\\n            if (changes.endTimeThreshold.currentValue instanceof String) {\\n                this.endTimeThreshold = new Date(value).getTime();\\n            } else if (value instanceof Date) {\\n                this.endTimeThreshold = value.getTime();\\n            } else if (typeof value === 'number') {\\n                this.endTimeThreshold = Number(value);\\n            }\\n            this.hoursPerRuler = Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600) < 24\\n                ? Math.ceil((Number(this.endTimeThreshold) - Number(this.startTimeThreshold)) / 1000 / 3600)\\n                : 24;\\n\\n        }\\n        if (changes.playTime) {\\n\\n            const value = changes.playTime.currentValue;\\n            if (changes.playTime.currentValue instanceof String) {\\n                this.playTime = new Date(value).getTime();\\n            } else if (value instanceof Date) {\\n                this.playTime = value.getTime();\\n            } else if (typeof value === 'number') {\\n                this.playTime = Number(value);\\n            }\\n\\n            // use SetTimeOut Timer to make it  asynchronous\\n            setTimeout(() => {\\n                this.set_time_to_middle(new Date(this.playTime).getTime());\\n            }, 100);\\n\\n        }\\n        if (changes.speed) {\\n\\n            this.speed = Number(changes.speed.currentValue) * 1000;\\n        }\\n        if (changes.forWardValue) {\\n\\n            this.forWardValue = Number(changes.forWardValue.currentValue) * 1000;\\n        }\\n\\n        if (changes.isPlayClick) {\\n            if (changes.isPlayClick.currentValue) {\\n                this.onPlayClick();\\n            } else {\\n                this.onPauseClick();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Initialize\\n     * @param  startTimestamp Leftmost time\\n     * @param  timecell Video segment array\\n     * @param  redrawFlag Whether to redraw the mark\\n     */\\n    init(startTimestamp: number, timecell: any, redrawFlag: boolean): void {\\n        this.timecell = timecell;\\n        this.startTimestamp = startTimestamp;\\n        if (\\n            this.currentTimestamp >=\\n            this.endTimeThreshold\\n        ) {\\n            this.startTimestamp =\\n                Number(this.endTimeThreshold) -\\n                (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n            this.currentTimestamp =\\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n            this.playTime =\\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n        } else if (\\n            this.currentTimestamp <=\\n            this.startTimeThreshold\\n        ) {\\n            this.startTimestamp =\\n                Number(this.startTimeThreshold) -\\n                (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n            this.currentTimestamp =\\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n            this.playTime =\\n                Number(this.startTimestamp) + (this.hoursPerRuler * this.playBarDistanceLeft * 1000 * 3600);\\n        }\\n        this.drawCellBg();\\n        this.add_graduations(startTimestamp);\\n        this.add_cells(timecell);\\n        // Draw the verticalBar\\n        this.drawLine(\\n            0,\\n            this.canvasH,\\n            this.canvasW,\\n            this.canvasH,\\n            this.bottomLineColor,\\n            1\\n        );\\n    }\\n\\n    /**\\n     * Draw add scale\\n     * @param  startTimestamp Leftmost time\\n     */\\n    add_graduations(startTimestamp: number): void {\\n        // px/min\\n        const pxPerMin = this.canvasW / (this.hoursPerRuler * 60);\\n        // px/ms\\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000);\\n        // The default minimum value of PX/steo is 20px\\n        let pxPerStep = this.graduationStep;\\n\\n        // Min/steo\\n        let minPerStep = pxPerStep / pxPerMin;\\n\\n        for (const v of this.minutesPerStep) {\\n            if (minPerStep <= v) {\\n                // Keep each cell within the range specified by minutesPerStep\\n                minPerStep = v;\\n                pxPerStep = pxPerMin * minPerStep;\\n                break;\\n            }\\n        }\\n        let mediumStep = 30;\\n        for (const v of this.minutesPerStep) {\\n            if (this.distanceBetweenGtitle / pxPerMin <= v) {\\n                mediumStep = v;\\n                break;\\n            }\\n        }\\n        // The total number\\n        const numSteps = this.canvasW / pxPerStep;\\n\\n        let graduationLeft: number;\\n        let graduationTime: number;\\n\\n        let caretClass: string;\\n        let lineH: number;\\n\\n        // The initial offset time (ms)\\n        const msOffset = this.ms_to_next_step(\\n            startTimestamp,\\n            minPerStep * 60 * 1000\\n        );\\n\\n        // The initial offset is (px)\\n        const pxOffset = msOffset * pxPerMs;\\n\\n        // ms/step\\n        const msPerStep = pxPerStep / pxPerMs;\\n\\n        for (let i = 0; i < numSteps; i++) {\\n            // Distance = offset distance to start + steps *px/ steps\\n            graduationLeft = pxOffset + i * pxPerStep;\\n\\n            // Time = left start time + offset time + steps *ms/ steps\\n            graduationTime =\\n                Number(startTimestamp) +\\n                Number(msOffset) +\\n                i * Number(msPerStep);\\n\\n            const date = new Date(graduationTime);\\n            if (date.getUTCHours() === 0 && date.getUTCMinutes() === 0) {\\n                caretClass = 'big';\\n                lineH = (this.scale * 1.25);\\n                const bigDate = DateUtil.formatDate(date, 'HH:mm:ss');\\n                this.ctx.textAlign = 'center';\\n                this.ctx.fillText(bigDate, graduationLeft, (this.scale * 1.5));\\n                this.ctx.fillStyle = this.verticalBarColor;\\n            } else if ((graduationTime / (60 * 1000)) % mediumStep === 0) {\\n                caretClass = 'middle';\\n                lineH = (this.scale * 0.75);\\n                const middleDate = DateUtil.formatDate(date, 'HH:mm:ss');\\n                this.ctx.textAlign = 'center';\\n                this.ctx.fillText(middleDate, graduationLeft, (this.scale * 1.5));\\n                this.ctx.fillStyle = this.verticalBarColor;\\n            } else {\\n                lineH = (this.scale * 0.5);\\n            }\\n            // drawLine(graduationLeft,0,graduationLeft,lineH,\\\"rgba(151,158,167,0.4)\\\",1);\\n            this.drawLine(\\n                graduationLeft,\\n                0,\\n                graduationLeft,\\n                lineH,\\n                this.verticalBarColor,\\n                1\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Draw the play button\\n     */\\n    drawPalyBar(): void {\\n        this.ctx.beginPath();\\n        this.ctx.moveTo(this.playBarOffsetX, 0);\\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\\n        this.ctx.strokeStyle = this.playBarColor;\\n        this.ctx.stroke();\\n        this.ctx.moveTo(this.playBarOffsetX, (this.scale * 1.75));\\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 2.5));\\n        this.ctx.lineTo(this.playBarOffsetX - (this.scale * 0.6), (this.scale * 3.5));\\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 3.5));\\n        this.ctx.lineTo(this.playBarOffsetX + (this.scale * 0.6), (this.scale * 2.5));\\n        this.ctx.lineTo(this.playBarOffsetX, (this.scale * 1.75));\\n        this.ctx.fillStyle = this.playBarColor;\\n        this.ctx.fill();\\n        this.ctx.closePath();\\n        // this.init(this.startTimestamp, this.timecell, false);\\n        const time = Number(this.currentTimestamp);\\n        this.ctx.fillStyle = this.playBarColor;\\n        this.ctx.textAlign = 'center';\\n        this.ctx.fillText(\\n            DateUtil.formatDate(new Date(time), 'YYYY-MM-DD HH:mm:ss'),\\n            this.playBarOffsetX,\\n            (this.scale * 4.25)\\n        );\\n    }\\n\\n    /**\\n     * Draw the line\\n     * @param  beginX The X-axis to start with\\n     * @param  beginY The Y-axis to start with\\n     * @param  endX The end of the X-axis\\n     * @param  endY The end of the Y-axis\\n     * @param  color color\\n     * @param  width width\\n     */\\n    drawLine(\\n        beginX: number,\\n        beginY: number,\\n        endX: number,\\n        endY: number,\\n        color: string,\\n        width: number\\n    ): void {\\n        this.ctx.beginPath();\\n        this.ctx.moveTo(beginX, beginY);\\n        this.ctx.lineTo(endX, endY);\\n        this.ctx.strokeStyle = color;\\n        this.ctx.lineWidth = width;\\n        this.ctx.stroke();\\n    }\\n\\n    /**\\n     * Add video segment\\n     * @param  cells Video array\\n     */\\n    add_cells(cells: any): void {\\n        cells.forEach((cell: MouseEvent) => {\\n            this.draw_cell(cell);\\n        });\\n    }\\n\\n    /**\\n     * Draw video blocks\\n     * @param  cell The cell includes beginTime Ms; The endTime ms; style;\\n     */\\n    draw_cell(cell: any): void {\\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 60 * 60 * 1000); // px/ms\\n        const beginX = (cell.beginTime - this.startTimestamp) * pxPerMs;\\n        const cellWidth = (cell.endTime - cell.beginTime) * pxPerMs;\\n        this.ctx.fillStyle = cell.style.background;\\n        this.ctx.fillRect(beginX, 0, cellWidth, (this.scale * 0.75));\\n    }\\n\\n    /**\\n     * Draws the background of the video block\\n     */\\n    drawCellBg(): void {\\n        this.ctx.fillStyle = 'rgba(69, 72, 76, 0.5)';\\n        this.ctx.fillRect(0, 0, this.canvasW, 0);\\n    }\\n\\n    /**\\n     * Drag/click the Mousedown event\\n     */\\n    mousedownFunc(e: MouseEvent): void {\\n        this.gIsMousedown = true;\\n        this.gMousedownCursor = this.get_cursor_x_position(e).posX;\\n        this.gMousedownCursorY = this.get_cursor_x_position(e).posY;\\n    }\\n\\n    /**\\n     * Drag/mouse hover to display mousemove events\\n     */\\n    mousemoveFunc(e: MouseEvent): void {\\n        this.clearCanvas();\\n        const posX = this.get_cursor_x_position(e).posX;\\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\\n        const diffX = posX - this.gMousedownCursor;\\n        if (this.gIsMousedown) {\\n            if (\\n                this.gMousedownCursor >= this.playBarOffsetX1 &&\\n                this.gMousedownCursor <= this.playBarOffsetX2 &&\\n                this.gMousedownCursorY >= this.playBarOffsetY1 &&\\n                this.gMousedownCursorY <= this.playBarOffsetY2\\n            ) {\\n                // this.playBarDistanceLeft = this.playBarOffsetX / this.pxPerMs / 3600 / 1000 / this.hoursPerRuler;\\n                // this.playBarOffsetX = posX;\\n                // this.playBarOffsetX1 = this.playBarOffsetX - (this.scale * 0.6);\\n                // this.playBarOffsetX2 = this.playBarOffsetX + (this.scale * 0.6);\\n\\n                this.startTimestamp =\\n                    this.startTimestamp + Math.round(diffX / pxPerMs);\\n\\n                this.currentTimestamp =\\n                    (this.startTimestamp +\\n                        Math.round(this.playBarOffsetX / pxPerMs));\\n\\n                this.drawPalyBar();\\n                this.init(this.startTimestamp, this.timecell, false);\\n\\n                this.gIsMousemove = true;\\n\\n            } else {\\n                this.startTimestamp =\\n                    this.startTimestamp - Math.round(diffX / pxPerMs);\\n\\n                this.currentTimestamp =\\n                    this.startTimestamp +\\n                    Math.round(this.playBarOffsetX / pxPerMs);\\n\\n                this.drawPalyBar();\\n                this.init(this.startTimestamp, this.timecell, true);\\n\\n                this.gIsMousemove = true;\\n                this.gMousedownCursor = posX;\\n\\n            }\\n            this.mouseUp.emit(this.currentTimestamp);\\n\\n        } else {\\n\\n            const time = this.startTimestamp + posX / pxPerMs;\\n\\n            this.drawPalyBar();\\n            this.init(this.startTimestamp, this.timecell, true);\\n            this.drawLine(posX, 0, posX, 50, 'rgb(194, 202, 215)', 1);\\n\\n            this.ctx.fillStyle = 'rgb(194, 202, 215)';\\n            this.ctx.textAlign = 'center';\\n            this.ctx.fillText(\\n                DateUtil.formatDate(\\n                    new Date(time),\\n                    'YYYY-MM-DD HH:mm:ss'\\n                ),\\n                posX,\\n                (this.scale * 3)\\n            );\\n\\n        }\\n    }\\n\\n    /**\\n     * Drag/click the Mouseup event\\n     */\\n    mouseupFunc(e: MouseEvent): void {\\n        if (this.gIsMousemove) {\\n            // Drag events\\n            this.gIsMousemove = false;\\n            this.gIsMousedown = false;\\n            this.playTime =\\n                this.startTimestamp + this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000;\\n        } else {\\n            // Click event\\n            this.gIsMousedown = false;\\n\\n            // Mouse distance (px)\\n            const posx = this.get_cursor_x_position(e).posX;\\n\\n            // ms/px\\n            const msPerPx = (this.zoom * 3600 * 1000) / this.canvasW;\\n\\n            this.playTime = this.startTimestamp + posx * msPerPx;\\n            this.set_time_to_middle(this.playTime);\\n\\n        }\\n        this.mouseDown.emit(this.playTime);\\n    }\\n\\n    /**\\n     * Mouseout of the hidden time mouseout event\\n     */\\n    mouseoutFunc(): void {\\n        this.clearCanvas();\\n        // px/ms\\n        const pxPerMs = this.canvasW / (this.hoursPerRuler * 3600 * 1000);\\n        this.currentTimestamp =\\n            this.startTimestamp +\\n            Math.round(this.playBarOffsetX / pxPerMs);\\n\\n        this.drawPalyBar();\\n        this.init(this.startTimestamp, this.timecell, true);\\n    }\\n\\n    /**\\n     * Scroll to the center of the timeline for the mousewheel event\\n     */\\n    mousewheelFunc(event: any): boolean {\\n        if (event && event.preventDefault) {\\n            event.preventDefault();\\n        } else {\\n            window.event.returnValue = false;\\n            return false;\\n        }\\n\\n        const e = window.event || event;\\n        const delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));\\n\\n        // Ms Remember the current middle time\\n        const middleTime =\\n            this.startTimestamp + (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\\n        if (delta < 0) {\\n            this.zoom = this.zoom + 4;\\n            if (this.zoom >= 24) {\\n                // Shrink to a minimum of 24 hours\\n                this.zoom = 24;\\n            }\\n            this.hoursPerRuler = this.zoom;\\n        } else if (delta > 0) {\\n            // amplification\\n            this.zoom = this.zoom - 4;\\n            if (this.zoom <= 1) {\\n                // Zoom in at most one hour\\n                this.zoom = 1;\\n            }\\n            this.hoursPerRuler = this.zoom;\\n        }\\n\\n        this.clearCanvas();\\n        // // startTimestamp = current middle time - zoom /2\\n        this.startTimestamp =\\n            middleTime - (this.hoursPerRuler * 3600 * 1000) / 2;\\n\\n        this.init(this.startTimestamp, this.timecell, true);\\n        this.drawPalyBar();\\n    }\\n\\n    /**\\n     * Get the mouse POSx\\n     * @param  e event\\n     */\\n    get_cursor_x_position(e: any): CanvasPos {\\n        let posx = 0;\\n        let posy = 0;\\n\\n        if (!e) {\\n            e = window.event;\\n        }\\n        if (e.offsetX || e.offsetY) {\\n            posx = e.offsetX;\\n            posy = e.offsetY;\\n        }\\n\\n        return { posX: posx, posY: posy };\\n    }\\n\\n    /**\\n     * The offset of the left start time, returns the unit ms\\n     * @param  timestamp The time stamp\\n     * @param  step The offset\\n     */\\n    ms_to_next_step(timestamp: number, step: number): number {\\n        const remainder = timestamp % step;\\n        return remainder ? step - remainder : 0;\\n    }\\n\\n    /**\\n     * Set the time to jump to the middle red line\\n     *  @param  time Unit of ms\\n     */\\n    set_time_to_middle(time: number): void {\\n        if (this.ctx) {\\n            this.clearCanvas();\\n            this.startTimestamp = time - (this.hoursPerRuler * this.playBarDistanceLeft * 3600 * 1000);\\n            this.currentTimestamp = time;\\n            this.drawPalyBar();\\n            this.init(this.startTimestamp, this.timecell, true);\\n        }\\n    }\\n\\n    /**\\n     * 清除canvas 每次重新绘制需要先清除\\n     */\\n    clearCanvas(): void {\\n        this.ctx.clearRect(0, 0, this.canvasW, (this.scale * 7.5));\\n    }\\n    /**\\n     * Click to play\\n     */\\n\\n    onPlayClick(): void {\\n        // this.setTimeMove = undefined;\\n        this.isPlayClick = true;\\n        this.setTimeMove = interval(this.speed).subscribe((d: any) => {\\n            this.playTime = Number(this.playTime) + 1 * 1000;\\n            this.playClick.emit(this.playTime);\\n            this.set_time_to_middle(this.playTime);\\n        });\\n    }\\n    /**\\n     * Click on the pause\\n     */\\n    onPauseClick(): void {\\n        this.isPlayClick = false;\\n        if (this.setTimeMove) {\\n            // this.setTimeMove = undefined;\\n            this.setTimeMove.unsubscribe();\\n            this.playClick.emit(this.playTime);\\n        }\\n    }\\n    /**\\n     * Change video segment\\n     */\\n    changeVideo(): void {\\n        const cells: Array<VideoCellType> = [\\n            {\\n                beginTime: new Date().getTime() - 1 * 1000 * 3600,\\n                endTime: new Date().getTime() + 2 * 1000 * 3600,\\n                style: {\\n                    background: 'rgba(132, 244, 180, 0.498039)'\\n                }\\n            }\\n        ];\\n        this.clearCanvas();\\n        this.drawPalyBar();\\n        this.init(this.startTimestamp, cells, true);\\n    }\\n\\n    /**\\n     * Temporary unused\\n     * @param event MatDatepickerInputEvent(Date)\\n     */\\n    selectedTime(event: any): void {\\n        const timestamp = new Date(event.value.getTime());\\n        this.set_time_to_middle(Number(timestamp));\\n    }\\n\\n    /**\\n     * Temporary unused\\n     * @param event MouseEvent\\n     */\\n    onDragStart(e: MouseEvent): boolean {\\n        e.preventDefault();\\n        return false;\\n    }\\n\\n\\n}\\n\",\"<canvas #timeline class=\\\"canvas\\\" [ngStyle]=\\\"{cursor: 'pointer',border: '1px solid',borderColor: borderColor,'backgroundColor': bgColor}\\\"\\n    (dragstart)=\\\"onDragStart($event)\\\" (mouseup)=\\\"mouseupFunc($event)\\\" (mousewheel)=\\\"mousewheelFunc($event)\\\"\\n    (mousedown)=\\\"mousedownFunc($event)\\\" (mousemove)=\\\"mousemoveFunc($event)\\\" (mouseout)=\\\"mouseoutFunc()\\\"></canvas>\\n\",\"import { NgModule } from '@angular/core';\\nimport { NgxVideoTimelineComponent } from './timeline.component';\\nimport { CommonModule } from '@angular/common';\\n\\n\\n\\n@NgModule({\\n    declarations: [NgxVideoTimelineComponent],\\n    imports: [\\n      CommonModule\\n    ],\\n    exports: [NgxVideoTimelineComponent]\\n})\\nexport class NgxVideoTimelineModule { }\\n\",\"/*\\n * Public API Surface of timeline\\n */\\n\\nexport * from './lib/timeline.component';\\nexport * from './lib/timeline.module';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}